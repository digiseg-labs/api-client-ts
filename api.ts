/* tslint:disable */
/* eslint-disable */
/**
 * Digiseg API
 * ### Digiseg API documentation  # Introduction  This API let you harness the power of Digisegs powerful and tracking-free segmentation engine.  Audiences by Digiseg are available in 50+ countries, probablistically mapping neighborhood characteristics to the IP addresses observed on the internet - Household targeting & measurement for the post-cookie world.  ## Developer SDKs  In addition to using these APIs directly through any HTTP client, we provide a set of API client SDKs for popular programming languages:  <div class=\"api-clients\">   <a class=\"api-client-box\" href=\"https://github.com/digiseg-labs/api-client-python\">     <i class=\"api-client-sdk-logo devicon-python-plain\"></i>     <p>API client for Python</p>   </a>   <a class=\"api-client-box\" href=\"https://github.com/digiseg-labs/api-client-go\">     <i class=\"api-client-sdk-logo devicon-go-original-wordmark\"></i>     <p>API client for Go</p>   </a> </div> <div class=\"api-clients-breaker\" />  ## Audience taxonomy  Digiseg audiences are grouped into private and business audiences. In each group there are categories that then contain the audiences. The API endpoints that communicate audiences and household characteristics, audience codes are being used.  The following table can be used as a reference for audience codes. Note that Digiseg will at times update names of audiences for purposes of internationalization, clarity or other such purposes - but the codes will remain as-is and should be considered a stable point of reference for the audience.  | Group | Category | Audience Code | Audience Name | |-------|----------|---------------|---------------| | private | home_type | a1 | Apartment | |  |  | a2 | House | |  | savings | b1 | No Savings | |  |  | b2 | Smaller Savings | |  |  | b3 | Larger Savings | |  | lifecycle | c1 | Young couples and singles | |  |  | c2 | Early family life | |  |  | c3 | Middle-aged families | |  |  | c4 | Mature families | |  |  | c5 | Pensioners | |  | cars | d1 | No cars | |  |  | d2 | 1 car | |  |  | d3 | 2 or more cars | |  | children | e1 | No children | |  |  | e2 | 1 child | |  |  | e3 | 2 or more children | |  | education | f1 | Basic | |  |  | f2 | Medium | |  |  | f3 | Higher | |  | neighbourhood_type | g1 | Countryside | |  |  | g2 | Village | |  |  | g3 | Suburban | |  |  | g4 | City | |  | income | h1 | Lowest 20% | |  |  | h2 | Lowest 20-40% | |  |  | h3 | Middle 40-60% | |  |  | h4 | Highest 60-80% | |  |  | h5 | Top 20% | |  | home_ownership | j1 | Rent | |  |  | j2 | Own | |  | building_age | k1 | Pre 1945 | |  |  | k2 | 1945-1989 | |  |  | k3 | 1990 until today | |  | living_space | l1 | Small | |  |  | l2 | Medium | |  |  | l3 | Large | |  | tech_level | n1 | Basic | |  |  | n2 | Medium | |  |  | n3 | High | | business | size | ba1 | Small Business | |  |  | ba2 | Medium Business | |  |  | ba3 | Larger Business |  There is also an interactive [Audience builder](https://digiseg.io/cookieless-audience-builder/) which lets you discover the targeting reach and power of combining various household characteristics into composite audiences. 
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@digiseg.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AccessTokenData
 */
export interface AccessTokenData {
    /**
     * A short-lived token (usable for 1 hour) to be used in subsequent requests
     * @type {string}
     * @memberof AccessTokenData
     */
    'access_token': string;
    /**
     * The type of access token returned
     * @type {string}
     * @memberof AccessTokenData
     */
    'token_type': string;
    /**
     * The duration of time (in seconds) the access token is granted for
     * @type {number}
     * @memberof AccessTokenData
     */
    'expires_in': number;
    /**
     * A long-lived token that can be used to generate new access tokens even after the returned access token expires.
     * @type {string}
     * @memberof AccessTokenData
     */
    'refresh_token'?: string;
}
/**
 * 
 * @export
 * @interface AccountAux
 */
export interface AccountAux {
    /**
     * ID of the user who is the ultimate owner of the account. Deprecated in favor of the `owner` role of the user\'s account membership.
     * @type {string}
     * @memberof AccountAux
     * @deprecated
     */
    'owner_id'?: string;
    /**
     * The email address to send billing information to. Requires `owner` role to change.
     * @type {string}
     * @memberof AccountAux
     */
    'billing_email'?: string;
    /**
     * 
     * @type {PostalAddress}
     * @memberof AccountAux
     */
    'billing_address'?: PostalAddress;
}
/**
 * 
 * @export
 * @interface AccountBase
 */
export interface AccountBase {
    /**
     * Human readable name of the account
     * @type {string}
     * @memberof AccountBase
     */
    'name'?: string;
    /**
     * The URL to the logo of the account
     * @type {string}
     * @memberof AccountBase
     */
    'logo_url'?: string;
    /**
     * URL of the account\'s primary website
     * @type {string}
     * @memberof AccountBase
     */
    'website_url'?: string;
    /**
     * Country code of the account. Requires `owner` role to change.
     * @type {string}
     * @memberof AccountBase
     */
    'billing_country'?: string;
    /**
     * The type of company that the account represents. Note that for forward-compatibility the data type here is simply a string. The values, if present, will however typically originate from the `CompanyType` enum. 
     * @type {string}
     * @memberof AccountBase
     */
    'company_type'?: string;
    /**
     * 
     * @type {CompanySize}
     * @memberof AccountBase
     */
    'company_size'?: CompanySize;
    /**
     * Determines whether the account has clients that they work for, or if their activities are for themselves.
     * @type {boolean}
     * @memberof AccountBase
     */
    'has_clients'?: boolean;
    /**
     * A short human-readable name to identify the account. Must be lower-case and between 4 and 16 characters.
     * @type {string}
     * @memberof AccountBase
     * @deprecated
     */
    'slug'?: string;
}


/**
 * 
 * @export
 * @interface AccountCreation
 */
export interface AccountCreation {
    /**
     * Human readable name of the account
     * @type {string}
     * @memberof AccountCreation
     */
    'name'?: string;
    /**
     * The URL to the logo of the account
     * @type {string}
     * @memberof AccountCreation
     */
    'logo_url'?: string;
    /**
     * URL of the account\'s primary website
     * @type {string}
     * @memberof AccountCreation
     */
    'website_url'?: string;
    /**
     * Country code of the account. Requires `owner` role to change.
     * @type {string}
     * @memberof AccountCreation
     */
    'billing_country'?: string;
    /**
     * 
     * @type {CompanyType}
     * @memberof AccountCreation
     */
    'company_type'?: CompanyType;
    /**
     * 
     * @type {CompanySize}
     * @memberof AccountCreation
     */
    'company_size'?: CompanySize;
    /**
     * Determines whether the account has clients that they work for, or if their activities are for themselves.
     * @type {boolean}
     * @memberof AccountCreation
     */
    'has_clients'?: boolean;
    /**
     * A short human-readable name to identify the account. Must be lower-case and between 4 and 16 characters.
     * @type {string}
     * @memberof AccountCreation
     * @deprecated
     */
    'slug'?: string;
    /**
     * ID of the user who is the ultimate owner of the account. Deprecated in favor of the `owner` role of the user\'s account membership.
     * @type {string}
     * @memberof AccountCreation
     * @deprecated
     */
    'owner_id'?: string;
    /**
     * The email address to send billing information to. Requires `owner` role to change.
     * @type {string}
     * @memberof AccountCreation
     */
    'billing_email'?: string;
    /**
     * 
     * @type {PostalAddress}
     * @memberof AccountCreation
     */
    'billing_address'?: PostalAddress;
    /**
     * 
     * @type {AccountOwnerCreation}
     * @memberof AccountCreation
     */
    'owner'?: AccountOwnerCreation;
    /**
     * Whether or not to notify the user that they have been registered
     * @type {boolean}
     * @memberof AccountCreation
     */
    'notify_user'?: boolean;
}


/**
 * 
 * @export
 * @interface AccountCreationAux
 */
export interface AccountCreationAux {
    /**
     * 
     * @type {AccountOwnerCreation}
     * @memberof AccountCreationAux
     */
    'owner'?: AccountOwnerCreation;
}
/**
 * 
 * @export
 * @interface AccountFull
 */
export interface AccountFull {
    /**
     * Unique ID for the object
     * @type {string}
     * @memberof AccountFull
     */
    'id'?: string;
    /**
     * Human readable name of the account
     * @type {string}
     * @memberof AccountFull
     */
    'name'?: string;
    /**
     * The URL to the logo of the account
     * @type {string}
     * @memberof AccountFull
     */
    'logo_url'?: string;
    /**
     * URL of the account\'s primary website
     * @type {string}
     * @memberof AccountFull
     */
    'website_url'?: string;
    /**
     * Country code of the account. Requires `owner` role to change.
     * @type {string}
     * @memberof AccountFull
     */
    'billing_country'?: string;
    /**
     * The type of company that the account represents. Note that for forward-compatibility the data type here is simply a string. The values, if present, will however typically originate from the `CompanyType` enum. 
     * @type {string}
     * @memberof AccountFull
     */
    'company_type'?: string;
    /**
     * 
     * @type {CompanySize}
     * @memberof AccountFull
     */
    'company_size'?: CompanySize;
    /**
     * Determines whether the account has clients that they work for, or if their activities are for themselves.
     * @type {boolean}
     * @memberof AccountFull
     */
    'has_clients'?: boolean;
    /**
     * A short human-readable name to identify the account. Must be lower-case and between 4 and 16 characters.
     * @type {string}
     * @memberof AccountFull
     * @deprecated
     */
    'slug'?: string;
    /**
     * ID of the user who is the ultimate owner of the account. Deprecated in favor of the `owner` role of the user\'s account membership.
     * @type {string}
     * @memberof AccountFull
     * @deprecated
     */
    'owner_id'?: string;
    /**
     * The email address to send billing information to. Requires `owner` role to change.
     * @type {string}
     * @memberof AccountFull
     */
    'billing_email'?: string;
    /**
     * 
     * @type {PostalAddress}
     * @memberof AccountFull
     */
    'billing_address'?: PostalAddress;
    /**
     * Date and time of the object creation
     * @type {string}
     * @memberof AccountFull
     */
    'created_at'?: string;
    /**
     * ID of the user who created the object
     * @type {string}
     * @memberof AccountFull
     */
    'created_by'?: string;
    /**
     * Date and time of the latest update to the object
     * @type {string}
     * @memberof AccountFull
     */
    'updated_at'?: string;
    /**
     * ID of the user who last updated the object
     * @type {string}
     * @memberof AccountFull
     */
    'updated_by'?: string;
}


/**
 * 
 * @export
 * @interface AccountItem
 */
export interface AccountItem {
    /**
     * Unique ID for the object
     * @type {string}
     * @memberof AccountItem
     */
    'id'?: string;
    /**
     * Human readable name of the account
     * @type {string}
     * @memberof AccountItem
     */
    'name'?: string;
    /**
     * The URL to the logo of the account
     * @type {string}
     * @memberof AccountItem
     */
    'logo_url'?: string;
    /**
     * URL of the account\'s primary website
     * @type {string}
     * @memberof AccountItem
     */
    'website_url'?: string;
    /**
     * Country code of the account. Requires `owner` role to change.
     * @type {string}
     * @memberof AccountItem
     */
    'billing_country'?: string;
    /**
     * The type of company that the account represents. Note that for forward-compatibility the data type here is simply a string. The values, if present, will however typically originate from the `CompanyType` enum. 
     * @type {string}
     * @memberof AccountItem
     */
    'company_type'?: string;
    /**
     * 
     * @type {CompanySize}
     * @memberof AccountItem
     */
    'company_size'?: CompanySize;
    /**
     * Determines whether the account has clients that they work for, or if their activities are for themselves.
     * @type {boolean}
     * @memberof AccountItem
     */
    'has_clients'?: boolean;
    /**
     * A short human-readable name to identify the account. Must be lower-case and between 4 and 16 characters.
     * @type {string}
     * @memberof AccountItem
     * @deprecated
     */
    'slug'?: string;
}


/**
 * 
 * @export
 * @interface AccountLinks
 */
export interface AccountLinks {
    /**
     * Link for getting to the account\'s users
     * @type {string}
     * @memberof AccountLinks
     */
    'users'?: string;
}
/**
 * 
 * @export
 * @interface AccountMutation
 */
export interface AccountMutation {
    /**
     * Human readable name of the account
     * @type {string}
     * @memberof AccountMutation
     */
    'name'?: string;
    /**
     * The URL to the logo of the account
     * @type {string}
     * @memberof AccountMutation
     */
    'logo_url'?: string;
    /**
     * URL of the account\'s primary website
     * @type {string}
     * @memberof AccountMutation
     */
    'website_url'?: string;
    /**
     * Country code of the account. Requires `owner` role to change.
     * @type {string}
     * @memberof AccountMutation
     */
    'billing_country'?: string;
    /**
     * 
     * @type {CompanyType}
     * @memberof AccountMutation
     */
    'company_type'?: CompanyType;
    /**
     * 
     * @type {CompanySize}
     * @memberof AccountMutation
     */
    'company_size'?: CompanySize;
    /**
     * Determines whether the account has clients that they work for, or if their activities are for themselves.
     * @type {boolean}
     * @memberof AccountMutation
     */
    'has_clients'?: boolean;
    /**
     * A short human-readable name to identify the account. Must be lower-case and between 4 and 16 characters.
     * @type {string}
     * @memberof AccountMutation
     * @deprecated
     */
    'slug'?: string;
    /**
     * ID of the user who is the ultimate owner of the account. Deprecated in favor of the `owner` role of the user\'s account membership.
     * @type {string}
     * @memberof AccountMutation
     * @deprecated
     */
    'owner_id'?: string;
    /**
     * The email address to send billing information to. Requires `owner` role to change.
     * @type {string}
     * @memberof AccountMutation
     */
    'billing_email'?: string;
    /**
     * 
     * @type {PostalAddress}
     * @memberof AccountMutation
     */
    'billing_address'?: PostalAddress;
}


/**
 * 
 * @export
 * @interface AccountMutationAux
 */
export interface AccountMutationAux {
    /**
     * 
     * @type {CompanyType}
     * @memberof AccountMutationAux
     */
    'company_type'?: CompanyType;
}


/**
 * 
 * @export
 * @interface AccountOwnerCreation
 */
export interface AccountOwnerCreation {
    /**
     * The account owner\'s name
     * @type {string}
     * @memberof AccountOwnerCreation
     */
    'name': string;
    /**
     * The account owner\'s email
     * @type {string}
     * @memberof AccountOwnerCreation
     */
    'email': string;
    /**
     * The account owner\'s password
     * @type {string}
     * @memberof AccountOwnerCreation
     */
    'password'?: string;
}
/**
 * 
 * @export
 * @interface AccountSubscriptionAux
 */
export interface AccountSubscriptionAux {
    /**
     * The ID of the account
     * @type {string}
     * @memberof AccountSubscriptionAux
     */
    'account_id': string;
    /**
     * 
     * @type {SubscriptionPlan}
     * @memberof AccountSubscriptionAux
     */
    'plan'?: SubscriptionPlan;
}
/**
 * 
 * @export
 * @interface AccountSubscriptionBase
 */
export interface AccountSubscriptionBase {
    /**
     * The ID of the subscription
     * @type {string}
     * @memberof AccountSubscriptionBase
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AccountSubscriptionBase
     */
    'start_date': string;
    /**
     * 
     * @type {string}
     * @memberof AccountSubscriptionBase
     */
    'end_date'?: string;
    /**
     * Is the subscription currently active or not?
     * @type {boolean}
     * @memberof AccountSubscriptionBase
     */
    'is_active': boolean;
}
/**
 * 
 * @export
 * @interface AccountSubscriptionCreation
 */
export interface AccountSubscriptionCreation {
    /**
     * The ID of the subscription
     * @type {string}
     * @memberof AccountSubscriptionCreation
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AccountSubscriptionCreation
     */
    'start_date': string;
    /**
     * 
     * @type {string}
     * @memberof AccountSubscriptionCreation
     */
    'end_date'?: string;
    /**
     * Is the subscription currently active or not?
     * @type {boolean}
     * @memberof AccountSubscriptionCreation
     */
    'is_active': boolean;
    /**
     * The ID of the plan to subscribe to
     * @type {string}
     * @memberof AccountSubscriptionCreation
     */
    'plan_id'?: string;
}
/**
 * 
 * @export
 * @interface AccountSubscriptionFull
 */
export interface AccountSubscriptionFull {
    /**
     * The ID of the subscription
     * @type {string}
     * @memberof AccountSubscriptionFull
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AccountSubscriptionFull
     */
    'start_date': string;
    /**
     * 
     * @type {string}
     * @memberof AccountSubscriptionFull
     */
    'end_date'?: string;
    /**
     * Is the subscription currently active or not?
     * @type {boolean}
     * @memberof AccountSubscriptionFull
     */
    'is_active': boolean;
    /**
     * The ID of the account
     * @type {string}
     * @memberof AccountSubscriptionFull
     */
    'account_id': string;
    /**
     * 
     * @type {SubscriptionPlan}
     * @memberof AccountSubscriptionFull
     */
    'plan'?: SubscriptionPlan;
    /**
     * Date and time of the object creation
     * @type {string}
     * @memberof AccountSubscriptionFull
     */
    'created_at'?: string;
    /**
     * ID of the user who created the object
     * @type {string}
     * @memberof AccountSubscriptionFull
     */
    'created_by'?: string;
    /**
     * Date and time of the latest update to the object
     * @type {string}
     * @memberof AccountSubscriptionFull
     */
    'updated_at'?: string;
    /**
     * ID of the user who last updated the object
     * @type {string}
     * @memberof AccountSubscriptionFull
     */
    'updated_by'?: string;
}
/**
 * 
 * @export
 * @interface AccountSubscriptionItem
 */
export interface AccountSubscriptionItem {
    /**
     * The ID of the subscription
     * @type {string}
     * @memberof AccountSubscriptionItem
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AccountSubscriptionItem
     */
    'start_date': string;
    /**
     * 
     * @type {string}
     * @memberof AccountSubscriptionItem
     */
    'end_date'?: string;
    /**
     * Is the subscription currently active or not?
     * @type {boolean}
     * @memberof AccountSubscriptionItem
     */
    'is_active': boolean;
}
/**
 * Summarizes an account\'s current subscription(s) and the feature set available
 * @export
 * @interface AccountSubscriptionsSummary
 */
export interface AccountSubscriptionsSummary {
    /**
     * The ID of the account
     * @type {string}
     * @memberof AccountSubscriptionsSummary
     */
    'account_id': string;
    /**
     * 
     * @type {Array<AccountSubscriptionItem>}
     * @memberof AccountSubscriptionsSummary
     */
    'subscriptions': Array<AccountSubscriptionItem>;
    /**
     * 
     * @type {PlanFeatureSet}
     * @memberof AccountSubscriptionsSummary
     */
    'feature_set': PlanFeatureSet;
}
/**
 * 
 * @export
 * @interface ApiKeyAux
 */
export interface ApiKeyAux {
    /**
     * 
     * @type {PermissionScopes}
     * @memberof ApiKeyAux
     */
    'scopes'?: PermissionScopes;
}
/**
 * 
 * @export
 * @interface ApiKeyBase
 */
export interface ApiKeyBase {
    /**
     * Human readable name of the API key
     * @type {string}
     * @memberof ApiKeyBase
     */
    'name'?: string;
    /**
     * 
     * @type {ApiKeyStatus}
     * @memberof ApiKeyBase
     */
    'status'?: ApiKeyStatus;
    /**
     * Optional date/time that the key will expire
     * @type {string}
     * @memberof ApiKeyBase
     */
    'expires_at'?: string;
    /**
     * The ID of the API key\'s user. 
     * @type {string}
     * @memberof ApiKeyBase
     */
    'user_id'?: string;
    /**
     * The ID of account that the API key is associated with. 
     * @type {string}
     * @memberof ApiKeyBase
     */
    'account_id'?: string;
    /**
     * The approximate last time that the API key was used to authenticate API requests
     * @type {string}
     * @memberof ApiKeyBase
     */
    'last_used_at'?: string;
    /**
     * A prefix of the API key
     * @type {string}
     * @memberof ApiKeyBase
     */
    'token_prefix'?: string;
}


/**
 * 
 * @export
 * @interface ApiKeyCreation
 */
export interface ApiKeyCreation {
    /**
     * Human readable name of the API key
     * @type {string}
     * @memberof ApiKeyCreation
     */
    'name'?: string;
    /**
     * 
     * @type {ApiKeyStatus}
     * @memberof ApiKeyCreation
     */
    'status'?: ApiKeyStatus;
    /**
     * Optional date/time that the key will expire
     * @type {string}
     * @memberof ApiKeyCreation
     */
    'expires_at'?: string;
    /**
     * The ID of the API key\'s user. 
     * @type {string}
     * @memberof ApiKeyCreation
     */
    'user_id'?: string;
    /**
     * The ID of account that the API key is associated with. 
     * @type {string}
     * @memberof ApiKeyCreation
     */
    'account_id'?: string;
    /**
     * The approximate last time that the API key was used to authenticate API requests
     * @type {string}
     * @memberof ApiKeyCreation
     */
    'last_used_at'?: string;
    /**
     * A prefix of the API key
     * @type {string}
     * @memberof ApiKeyCreation
     */
    'token_prefix'?: string;
    /**
     * 
     * @type {PermissionScopes}
     * @memberof ApiKeyCreation
     */
    'scopes'?: PermissionScopes;
}


/**
 * 
 * @export
 * @interface ApiKeyFull
 */
export interface ApiKeyFull {
    /**
     * Unique ID for the object
     * @type {string}
     * @memberof ApiKeyFull
     */
    'id'?: string;
    /**
     * Human readable name of the API key
     * @type {string}
     * @memberof ApiKeyFull
     */
    'name'?: string;
    /**
     * 
     * @type {ApiKeyStatus}
     * @memberof ApiKeyFull
     */
    'status'?: ApiKeyStatus;
    /**
     * Optional date/time that the key will expire
     * @type {string}
     * @memberof ApiKeyFull
     */
    'expires_at'?: string;
    /**
     * The ID of the API key\'s user. 
     * @type {string}
     * @memberof ApiKeyFull
     */
    'user_id'?: string;
    /**
     * The ID of account that the API key is associated with. 
     * @type {string}
     * @memberof ApiKeyFull
     */
    'account_id'?: string;
    /**
     * The approximate last time that the API key was used to authenticate API requests
     * @type {string}
     * @memberof ApiKeyFull
     */
    'last_used_at'?: string;
    /**
     * A prefix of the API key
     * @type {string}
     * @memberof ApiKeyFull
     */
    'token_prefix'?: string;
    /**
     * 
     * @type {PermissionScopes}
     * @memberof ApiKeyFull
     */
    'scopes'?: PermissionScopes;
    /**
     * Date and time of the object creation
     * @type {string}
     * @memberof ApiKeyFull
     */
    'created_at'?: string;
    /**
     * ID of the user who created the object
     * @type {string}
     * @memberof ApiKeyFull
     */
    'created_by'?: string;
    /**
     * Date and time of the latest update to the object
     * @type {string}
     * @memberof ApiKeyFull
     */
    'updated_at'?: string;
    /**
     * ID of the user who last updated the object
     * @type {string}
     * @memberof ApiKeyFull
     */
    'updated_by'?: string;
}


/**
 * 
 * @export
 * @interface ApiKeyFullWithToken
 */
export interface ApiKeyFullWithToken {
    /**
     * The actual API key token to use with the `X-API-KEY` header to authenticate with the key
     * @type {string}
     * @memberof ApiKeyFullWithToken
     */
    'token'?: string;
    /**
     * Unique ID for the object
     * @type {string}
     * @memberof ApiKeyFullWithToken
     */
    'id'?: string;
    /**
     * Human readable name of the API key
     * @type {string}
     * @memberof ApiKeyFullWithToken
     */
    'name'?: string;
    /**
     * 
     * @type {ApiKeyStatus}
     * @memberof ApiKeyFullWithToken
     */
    'status'?: ApiKeyStatus;
    /**
     * Optional date/time that the key will expire
     * @type {string}
     * @memberof ApiKeyFullWithToken
     */
    'expires_at'?: string;
    /**
     * The ID of the API key\'s user. 
     * @type {string}
     * @memberof ApiKeyFullWithToken
     */
    'user_id'?: string;
    /**
     * The ID of account that the API key is associated with. 
     * @type {string}
     * @memberof ApiKeyFullWithToken
     */
    'account_id'?: string;
    /**
     * The approximate last time that the API key was used to authenticate API requests
     * @type {string}
     * @memberof ApiKeyFullWithToken
     */
    'last_used_at'?: string;
    /**
     * A prefix of the API key
     * @type {string}
     * @memberof ApiKeyFullWithToken
     */
    'token_prefix'?: string;
    /**
     * 
     * @type {PermissionScopes}
     * @memberof ApiKeyFullWithToken
     */
    'scopes'?: PermissionScopes;
    /**
     * Date and time of the object creation
     * @type {string}
     * @memberof ApiKeyFullWithToken
     */
    'created_at'?: string;
    /**
     * ID of the user who created the object
     * @type {string}
     * @memberof ApiKeyFullWithToken
     */
    'created_by'?: string;
    /**
     * Date and time of the latest update to the object
     * @type {string}
     * @memberof ApiKeyFullWithToken
     */
    'updated_at'?: string;
    /**
     * ID of the user who last updated the object
     * @type {string}
     * @memberof ApiKeyFullWithToken
     */
    'updated_by'?: string;
}


/**
 * 
 * @export
 * @interface ApiKeyItem
 */
export interface ApiKeyItem {
    /**
     * Unique ID for the object
     * @type {string}
     * @memberof ApiKeyItem
     */
    'id'?: string;
    /**
     * Human readable name of the API key
     * @type {string}
     * @memberof ApiKeyItem
     */
    'name'?: string;
    /**
     * 
     * @type {ApiKeyStatus}
     * @memberof ApiKeyItem
     */
    'status'?: ApiKeyStatus;
    /**
     * Optional date/time that the key will expire
     * @type {string}
     * @memberof ApiKeyItem
     */
    'expires_at'?: string;
    /**
     * The ID of the API key\'s user. 
     * @type {string}
     * @memberof ApiKeyItem
     */
    'user_id'?: string;
    /**
     * The ID of account that the API key is associated with. 
     * @type {string}
     * @memberof ApiKeyItem
     */
    'account_id'?: string;
    /**
     * The approximate last time that the API key was used to authenticate API requests
     * @type {string}
     * @memberof ApiKeyItem
     */
    'last_used_at'?: string;
    /**
     * A prefix of the API key
     * @type {string}
     * @memberof ApiKeyItem
     */
    'token_prefix'?: string;
}


/**
 * 
 * @export
 * @interface ApiKeyLinks
 */
export interface ApiKeyLinks {
    /**
     * Link for getting to the api key\'s user
     * @type {string}
     * @memberof ApiKeyLinks
     */
    'user'?: string;
}
/**
 * 
 * @export
 * @interface ApiKeyMutation
 */
export interface ApiKeyMutation {
    /**
     * Human readable name of the API key
     * @type {string}
     * @memberof ApiKeyMutation
     */
    'name'?: string;
    /**
     * 
     * @type {ApiKeyStatus}
     * @memberof ApiKeyMutation
     */
    'status'?: ApiKeyStatus;
    /**
     * Optional date/time that the key will expire
     * @type {string}
     * @memberof ApiKeyMutation
     */
    'expires_at'?: string;
    /**
     * The ID of the API key\'s user. 
     * @type {string}
     * @memberof ApiKeyMutation
     */
    'user_id'?: string;
    /**
     * The ID of account that the API key is associated with. 
     * @type {string}
     * @memberof ApiKeyMutation
     */
    'account_id'?: string;
    /**
     * The approximate last time that the API key was used to authenticate API requests
     * @type {string}
     * @memberof ApiKeyMutation
     */
    'last_used_at'?: string;
    /**
     * A prefix of the API key
     * @type {string}
     * @memberof ApiKeyMutation
     */
    'token_prefix'?: string;
    /**
     * 
     * @type {PermissionScopes}
     * @memberof ApiKeyMutation
     */
    'scopes'?: PermissionScopes;
}


/**
 * Describes the status of the API key. The status can be set to active or disabled manually. It will become expired automatically, if the expiry date has been surpassed. 
 * @export
 * @enum {string}
 */

export const ApiKeyStatus = {
    Enabled: 'enabled',
    Disabled: 'disabled',
    Expired: 'expired'
} as const;

export type ApiKeyStatus = typeof ApiKeyStatus[keyof typeof ApiKeyStatus];


/**
 * Contains the generated API key which is only revealed right after generation
 * @export
 * @interface ApiKeyToken
 */
export interface ApiKeyToken {
    /**
     * The actual API key token to use with the `X-API-KEY` header to authenticate with the key
     * @type {string}
     * @memberof ApiKeyToken
     */
    'token'?: string;
}
/**
 * An object that represents an audience matched to the request
 * @export
 * @interface Audience
 */
export interface Audience {
    /**
     * The audience category
     * @type {string}
     * @memberof Audience
     */
    'category'?: string;
    /**
     * The unique audience code
     * @type {string}
     * @memberof Audience
     */
    'code'?: string;
    /**
     * The name of the audience, typically of the form \"{category name} > {audience name}\"
     * @type {string}
     * @memberof Audience
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface AudienceCategoryStats
 */
export interface AudienceCategoryStats {
    /**
     * The name of the audience category
     * @type {string}
     * @memberof AudienceCategoryStats
     */
    'name': string;
    /**
     * 
     * @type {Array<AudienceStats>}
     * @memberof AudienceCategoryStats
     */
    'audiences': Array<AudienceStats>;
}
/**
 * 
 * @export
 * @interface AudienceDataDailyUsage
 */
export interface AudienceDataDailyUsage {
    /**
     * Date in ISO 8601 format
     * @type {string}
     * @memberof AudienceDataDailyUsage
     */
    'date': string;
    /**
     * 
     * @type {AudienceDataUsage}
     * @memberof AudienceDataDailyUsage
     */
    'usage': AudienceDataUsage;
}
/**
 * 
 * @export
 * @interface AudienceDataMonthlyUsage
 */
export interface AudienceDataMonthlyUsage {
    /**
     * Year number
     * @type {number}
     * @memberof AudienceDataMonthlyUsage
     */
    'year': number;
    /**
     * Month number (1-12)
     * @type {number}
     * @memberof AudienceDataMonthlyUsage
     */
    'month': number;
    /**
     * 
     * @type {AudienceDataUsage}
     * @memberof AudienceDataMonthlyUsage
     */
    'usage': AudienceDataUsage;
}
/**
 * 
 * @export
 * @interface AudienceDataRealtimeUsage
 */
export interface AudienceDataRealtimeUsage {
    /**
     * The point in time of recording the usage data
     * @type {string}
     * @memberof AudienceDataRealtimeUsage
     */
    'when': string;
    /**
     * 
     * @type {AudienceDataUsage}
     * @memberof AudienceDataRealtimeUsage
     */
    'usage': AudienceDataUsage;
}
/**
 * 
 * @export
 * @interface AudienceDataUsage
 */
export interface AudienceDataUsage {
    /**
     * Number of records fulfilled
     * @type {number}
     * @memberof AudienceDataUsage
     */
    'records_fulfilled'?: number;
    /**
     * Number of records processed
     * @type {number}
     * @memberof AudienceDataUsage
     */
    'records_processed'?: number;
}
/**
 * 
 * @export
 * @interface AudienceExampleInput
 */
export interface AudienceExampleInput {
    /**
     * The IP address to resolve audiences for
     * @type {string}
     * @memberof AudienceExampleInput
     */
    'ip_address'?: string;
}
/**
 * 
 * @export
 * @interface AudienceExampleInputsResponse
 */
export interface AudienceExampleInputsResponse {
    /**
     * 
     * @type {Array<AudienceExampleInput>}
     * @memberof AudienceExampleInputsResponse
     */
    'data': Array<AudienceExampleInput>;
}
/**
 * 
 * @export
 * @interface AudienceResponse
 */
export interface AudienceResponse {
    /**
     * 
     * @type {Array<Audience>}
     * @memberof AudienceResponse
     */
    'audiences'?: Array<Audience>;
    /**
     * 
     * @type {AudienceResponseStatus}
     * @memberof AudienceResponse
     */
    'status': AudienceResponseStatus;
}


/**
 * Describes the result of resolving the audiences of an IP address. `resolved` means that the IP was resolved and audiences are returned. `unresolved` means that the IP could not be resolved and no audiences are returned. `forbidden` means that the authenticated user did not have grants to resolve audiences in the country of the IP. 
 * @export
 * @enum {string}
 */

export const AudienceResponseStatus = {
    Resolved: 'resolved',
    Unresolved: 'unresolved',
    Forbidden: 'forbidden'
} as const;

export type AudienceResponseStatus = typeof AudienceResponseStatus[keyof typeof AudienceResponseStatus];


/**
 * 
 * @export
 * @interface AudienceStats
 */
export interface AudienceStats {
    /**
     * Measurements related to this object
     * @type {Array<Measurement>}
     * @memberof AudienceStats
     */
    'measurements': Array<Measurement>;
    /**
     * 
     * @type {Array<Comparison>}
     * @memberof AudienceStats
     */
    'comparisons'?: Array<Comparison>;
    /**
     * The code of the audience
     * @type {string}
     * @memberof AudienceStats
     */
    'code': string;
    /**
     * The name of the audience
     * @type {string}
     * @memberof AudienceStats
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface AuthTokenRequest
 */
export interface AuthTokenRequest {
    /**
     * The username (typically an email address) of the user to authenticate
     * @type {string}
     * @memberof AuthTokenRequest
     */
    'username': string;
    /**
     * A one-time password provided to perform passwordless auth
     * @type {string}
     * @memberof AuthTokenRequest
     */
    'otp'?: string;
    /**
     * The password for the given username
     * @type {string}
     * @memberof AuthTokenRequest
     */
    'password'?: string;
    /**
     * A previously issued refresh token for the given username
     * @type {string}
     * @memberof AuthTokenRequest
     */
    'refresh_token'?: string;
    /**
     * 
     * @type {PermissionScopes}
     * @memberof AuthTokenRequest
     */
    'scopes'?: PermissionScopes;
}
/**
 * 
 * @export
 * @interface AuthTokenResponse
 */
export interface AuthTokenResponse {
    /**
     * A short-lived token (usable for 1 hour) to be used in subsequent requests
     * @type {string}
     * @memberof AuthTokenResponse
     */
    'access_token': string;
    /**
     * The type of access token returned
     * @type {string}
     * @memberof AuthTokenResponse
     */
    'token_type': string;
    /**
     * The duration of time (in seconds) the access token is granted for
     * @type {number}
     * @memberof AuthTokenResponse
     */
    'expires_in': number;
    /**
     * A long-lived token that can be used to generate new access tokens even after the returned access token expires.
     * @type {string}
     * @memberof AuthTokenResponse
     */
    'refresh_token'?: string;
}
/**
 * Measurements (overall and per audience) for traffic resolved as business users
 * @export
 * @interface BusinessAudienceStats
 */
export interface BusinessAudienceStats {
    /**
     * Measurements related to this object
     * @type {Array<Measurement>}
     * @memberof BusinessAudienceStats
     */
    'measurements': Array<Measurement>;
    /**
     * 
     * @type {BusinessAudienceStatsAudienceCategories}
     * @memberof BusinessAudienceStats
     */
    'audience_categories'?: BusinessAudienceStatsAudienceCategories;
}
/**
 * 
 * @export
 * @interface BusinessAudienceStatsAudienceCategories
 */
export interface BusinessAudienceStatsAudienceCategories {
    /**
     * 
     * @type {AudienceCategoryStats}
     * @memberof BusinessAudienceStatsAudienceCategories
     */
    'size': AudienceCategoryStats;
}
/**
 * 
 * @export
 * @interface CategoryPopulationsFull
 */
export interface CategoryPopulationsFull {
    /**
     * 
     * @type {Array<PopulationItem>}
     * @memberof CategoryPopulationsFull
     */
    'populations'?: Array<PopulationItem>;
}
/**
 * Describes the size of a company
 * @export
 * @enum {string}
 */

export const CompanySize = {
    SelfEmployed: 'Self-employed',
    _110Employees: '1-10 employees',
    _1150Employees: '11-50 employees',
    _51200Employees: '51-200 employees',
    _201500Employees: '201-500 employees',
    _5011000Employees: '501-1000 employees',
    _10015000Employees: '1001-5000 employees',
    _500110000Employees: '5001-10,000 employees',
    _10001Employees: '10,001+ employees'
} as const;

export type CompanySize = typeof CompanySize[keyof typeof CompanySize];


/**
 * A type of company that an account can represent
 * @export
 * @enum {string}
 */

export const CompanyType = {
    Advertiser: 'advertiser',
    Agency: 'agency',
    Publisher: 'publisher',
    TechnologyProvider: 'technology_provider',
    Other: 'other'
} as const;

export type CompanyType = typeof CompanyType[keyof typeof CompanyType];


/**
 * Represents a comparison of measurements with another source
 * @export
 * @interface Comparison
 */
export interface Comparison {
    /**
     * The name of the comparison source
     * @type {string}
     * @memberof Comparison
     */
    'name': string;
    /**
     * The code of the comparison source
     * @type {string}
     * @memberof Comparison
     */
    'code': string;
    /**
     * The \"fraction of total\" value that is being compared with. 
     * @type {number}
     * @memberof Comparison
     */
    'fraction_of_total': number;
    /**
     * The comparison index where 100 means that the measurement is completely aligned with the compared metric. Values below 100 means that the measurement is below the compared metric, and values above 100 means that the measurement is above the compared metric. 
     * @type {number}
     * @memberof Comparison
     */
    'index': number;
}
/**
 * An object containing comparisons
 * @export
 * @interface ComparisonsContainer
 */
export interface ComparisonsContainer {
    /**
     * 
     * @type {Array<Comparison>}
     * @memberof ComparisonsContainer
     */
    'comparisons'?: Array<Comparison>;
}
/**
 * 
 * @export
 * @interface CountryStats
 */
export interface CountryStats {
    /**
     * Measurements related to this object
     * @type {Array<Measurement>}
     * @memberof CountryStats
     */
    'measurements': Array<Measurement>;
    /**
     * Country code of the country
     * @type {string}
     * @memberof CountryStats
     */
    'code': string;
}
/**
 * 
 * @export
 * @interface CreateApiKey201Response
 */
export interface CreateApiKey201Response {
    /**
     * 
     * @type {ApiKeyFullWithToken}
     * @memberof CreateApiKey201Response
     */
    'data'?: ApiKeyFullWithToken;
}
/**
 * 
 * @export
 * @interface CreateMeasurementClient201Response
 */
export interface CreateMeasurementClient201Response {
    /**
     * 
     * @type {MeasurementClientFull}
     * @memberof CreateMeasurementClient201Response
     */
    'data'?: MeasurementClientFull;
}
/**
 * 
 * @export
 * @interface CreateStudy201Response
 */
export interface CreateStudy201Response {
    /**
     * 
     * @type {StudyFull}
     * @memberof CreateStudy201Response
     */
    'data'?: StudyFull;
    /**
     * 
     * @type {StudyLinks}
     * @memberof CreateStudy201Response
     */
    'links'?: StudyLinks;
    /**
     * 
     * @type {StudyMeta}
     * @memberof CreateStudy201Response
     */
    'meta'?: StudyMeta;
}
/**
 * 
 * @export
 * @interface CreateUserInAccount201Response
 */
export interface CreateUserInAccount201Response {
    /**
     * 
     * @type {UserFull}
     * @memberof CreateUserInAccount201Response
     */
    'data'?: UserFull;
    /**
     * 
     * @type {UserLinks}
     * @memberof CreateUserInAccount201Response
     */
    'links'?: UserLinks;
}
/**
 * Contains statistics about the day of the month that study activity has been measured. The time zone used to record these measurements is the time zone of the measured user, or UTC if the user\'s location cannot be resolved. 
 * @export
 * @interface DayOfMonthStats
 */
export interface DayOfMonthStats {
    /**
     * 
     * @type {MeasurementsContainer}
     * @memberof DayOfMonthStats
     */
    '0'?: MeasurementsContainer;
    /**
     * 
     * @type {MeasurementsContainer}
     * @memberof DayOfMonthStats
     */
    '1'?: MeasurementsContainer;
    /**
     * 
     * @type {MeasurementsContainer}
     * @memberof DayOfMonthStats
     */
    '2'?: MeasurementsContainer;
    /**
     * 
     * @type {MeasurementsContainer}
     * @memberof DayOfMonthStats
     */
    '3'?: MeasurementsContainer;
    /**
     * 
     * @type {MeasurementsContainer}
     * @memberof DayOfMonthStats
     */
    '4'?: MeasurementsContainer;
    /**
     * 
     * @type {MeasurementsContainer}
     * @memberof DayOfMonthStats
     */
    '5'?: MeasurementsContainer;
    /**
     * 
     * @type {MeasurementsContainer}
     * @memberof DayOfMonthStats
     */
    '6'?: MeasurementsContainer;
    /**
     * 
     * @type {MeasurementsContainer}
     * @memberof DayOfMonthStats
     */
    '7'?: MeasurementsContainer;
    /**
     * 
     * @type {MeasurementsContainer}
     * @memberof DayOfMonthStats
     */
    '8'?: MeasurementsContainer;
    /**
     * 
     * @type {MeasurementsContainer}
     * @memberof DayOfMonthStats
     */
    '9'?: MeasurementsContainer;
    /**
     * 
     * @type {MeasurementsContainer}
     * @memberof DayOfMonthStats
     */
    '10'?: MeasurementsContainer;
    /**
     * 
     * @type {MeasurementsContainer}
     * @memberof DayOfMonthStats
     */
    '11'?: MeasurementsContainer;
    /**
     * 
     * @type {MeasurementsContainer}
     * @memberof DayOfMonthStats
     */
    '12'?: MeasurementsContainer;
    /**
     * 
     * @type {MeasurementsContainer}
     * @memberof DayOfMonthStats
     */
    '13'?: MeasurementsContainer;
    /**
     * 
     * @type {MeasurementsContainer}
     * @memberof DayOfMonthStats
     */
    '14'?: MeasurementsContainer;
    /**
     * 
     * @type {MeasurementsContainer}
     * @memberof DayOfMonthStats
     */
    '15'?: MeasurementsContainer;
    /**
     * 
     * @type {MeasurementsContainer}
     * @memberof DayOfMonthStats
     */
    '16'?: MeasurementsContainer;
    /**
     * 
     * @type {MeasurementsContainer}
     * @memberof DayOfMonthStats
     */
    '17'?: MeasurementsContainer;
    /**
     * 
     * @type {MeasurementsContainer}
     * @memberof DayOfMonthStats
     */
    '18'?: MeasurementsContainer;
    /**
     * 
     * @type {MeasurementsContainer}
     * @memberof DayOfMonthStats
     */
    '19'?: MeasurementsContainer;
    /**
     * 
     * @type {MeasurementsContainer}
     * @memberof DayOfMonthStats
     */
    '20'?: MeasurementsContainer;
    /**
     * 
     * @type {MeasurementsContainer}
     * @memberof DayOfMonthStats
     */
    '21'?: MeasurementsContainer;
    /**
     * 
     * @type {MeasurementsContainer}
     * @memberof DayOfMonthStats
     */
    '22'?: MeasurementsContainer;
    /**
     * 
     * @type {MeasurementsContainer}
     * @memberof DayOfMonthStats
     */
    '23'?: MeasurementsContainer;
    /**
     * 
     * @type {MeasurementsContainer}
     * @memberof DayOfMonthStats
     */
    '24'?: MeasurementsContainer;
    /**
     * 
     * @type {MeasurementsContainer}
     * @memberof DayOfMonthStats
     */
    '25'?: MeasurementsContainer;
    /**
     * 
     * @type {MeasurementsContainer}
     * @memberof DayOfMonthStats
     */
    '26'?: MeasurementsContainer;
    /**
     * 
     * @type {MeasurementsContainer}
     * @memberof DayOfMonthStats
     */
    '27'?: MeasurementsContainer;
    /**
     * 
     * @type {MeasurementsContainer}
     * @memberof DayOfMonthStats
     */
    '28'?: MeasurementsContainer;
    /**
     * 
     * @type {MeasurementsContainer}
     * @memberof DayOfMonthStats
     */
    '29'?: MeasurementsContainer;
    /**
     * 
     * @type {MeasurementsContainer}
     * @memberof DayOfMonthStats
     */
    '30'?: MeasurementsContainer;
    /**
     * 
     * @type {MeasurementsContainer}
     * @memberof DayOfMonthStats
     */
    '31'?: MeasurementsContainer;
}
/**
 * Contains statistics about the week days that study activity has been measured. The time zone used to record these measurements is the time zone of the measured user, or UTC if the user\'s location cannot be resolved. 
 * @export
 * @interface DayOfWeekStats
 */
export interface DayOfWeekStats {
    /**
     * 
     * @type {MeasurementsContainer}
     * @memberof DayOfWeekStats
     */
    'Monday'?: MeasurementsContainer;
    /**
     * 
     * @type {MeasurementsContainer}
     * @memberof DayOfWeekStats
     */
    'Tuesday'?: MeasurementsContainer;
    /**
     * 
     * @type {MeasurementsContainer}
     * @memberof DayOfWeekStats
     */
    'Wednesday'?: MeasurementsContainer;
    /**
     * 
     * @type {MeasurementsContainer}
     * @memberof DayOfWeekStats
     */
    'Thursday'?: MeasurementsContainer;
    /**
     * 
     * @type {MeasurementsContainer}
     * @memberof DayOfWeekStats
     */
    'Friday'?: MeasurementsContainer;
    /**
     * 
     * @type {MeasurementsContainer}
     * @memberof DayOfWeekStats
     */
    'Saturday'?: MeasurementsContainer;
    /**
     * 
     * @type {MeasurementsContainer}
     * @memberof DayOfWeekStats
     */
    'Sunday'?: MeasurementsContainer;
}
/**
 * 
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * 
     * @type {number}
     * @memberof ErrorResponse
     */
    'code': number;
    /**
     * A human-readable error message
     * @type {string}
     * @memberof ErrorResponse
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface FrequencyStats
 */
export interface FrequencyStats {
    /**
     * A frequency of study impressions to users. * The value 1 means that the study has been exposed just once. * The value 2 means that the study has been exposed twice. * And so on... 
     * @type {number}
     * @memberof FrequencyStats
     */
    'frequency'?: number;
    /**
     * The number of users that have generated impressions at the corresponding frequency
     * @type {number}
     * @memberof FrequencyStats
     */
    'count'?: number;
}
/**
 * 
 * @export
 * @interface GetAccountById200Response
 */
export interface GetAccountById200Response {
    /**
     * 
     * @type {AccountFull}
     * @memberof GetAccountById200Response
     */
    'data'?: AccountFull;
    /**
     * 
     * @type {AccountLinks}
     * @memberof GetAccountById200Response
     */
    'links'?: AccountLinks;
}
/**
 * 
 * @export
 * @interface GetAccountSubscriptionById200Response
 */
export interface GetAccountSubscriptionById200Response {
    /**
     * 
     * @type {AccountSubscriptionFull}
     * @memberof GetAccountSubscriptionById200Response
     */
    'data'?: AccountSubscriptionFull;
}
/**
 * 
 * @export
 * @interface GetAccountSubscriptions200Response
 */
export interface GetAccountSubscriptions200Response {
    /**
     * 
     * @type {AccountSubscriptionsSummary}
     * @memberof GetAccountSubscriptions200Response
     */
    'data'?: AccountSubscriptionsSummary;
}
/**
 * 
 * @export
 * @interface GetApiKeyById200Response
 */
export interface GetApiKeyById200Response {
    /**
     * 
     * @type {ApiKeyFull}
     * @memberof GetApiKeyById200Response
     */
    'data'?: ApiKeyFull;
    /**
     * 
     * @type {ApiKeyLinks}
     * @memberof GetApiKeyById200Response
     */
    'links'?: ApiKeyLinks;
}
/**
 * 
 * @export
 * @interface GetPopuplationByKey200Response
 */
export interface GetPopuplationByKey200Response {
    /**
     * 
     * @type {PopulationFull}
     * @memberof GetPopuplationByKey200Response
     */
    'data'?: PopulationFull;
}
/**
 * Contains statistics about the time of day that study activity has been measured. The 24 hour time format is used to represent measurements for each hour. The time zone used to record these measurements is the time zone of the measured user, or UTC if the user\'s location cannot be resolved. 
 * @export
 * @interface HourOfDayStats
 */
export interface HourOfDayStats {
    /**
     * 
     * @type {MeasurementsContainer}
     * @memberof HourOfDayStats
     */
    '10'?: MeasurementsContainer;
    /**
     * 
     * @type {MeasurementsContainer}
     * @memberof HourOfDayStats
     */
    '11'?: MeasurementsContainer;
    /**
     * 
     * @type {MeasurementsContainer}
     * @memberof HourOfDayStats
     */
    '12'?: MeasurementsContainer;
    /**
     * 
     * @type {MeasurementsContainer}
     * @memberof HourOfDayStats
     */
    '13'?: MeasurementsContainer;
    /**
     * 
     * @type {MeasurementsContainer}
     * @memberof HourOfDayStats
     */
    '14'?: MeasurementsContainer;
    /**
     * 
     * @type {MeasurementsContainer}
     * @memberof HourOfDayStats
     */
    '15'?: MeasurementsContainer;
    /**
     * 
     * @type {MeasurementsContainer}
     * @memberof HourOfDayStats
     */
    '16'?: MeasurementsContainer;
    /**
     * 
     * @type {MeasurementsContainer}
     * @memberof HourOfDayStats
     */
    '17'?: MeasurementsContainer;
    /**
     * 
     * @type {MeasurementsContainer}
     * @memberof HourOfDayStats
     */
    '18'?: MeasurementsContainer;
    /**
     * 
     * @type {MeasurementsContainer}
     * @memberof HourOfDayStats
     */
    '19'?: MeasurementsContainer;
    /**
     * 
     * @type {MeasurementsContainer}
     * @memberof HourOfDayStats
     */
    '20'?: MeasurementsContainer;
    /**
     * 
     * @type {MeasurementsContainer}
     * @memberof HourOfDayStats
     */
    '21'?: MeasurementsContainer;
    /**
     * 
     * @type {MeasurementsContainer}
     * @memberof HourOfDayStats
     */
    '22'?: MeasurementsContainer;
    /**
     * 
     * @type {MeasurementsContainer}
     * @memberof HourOfDayStats
     */
    '23'?: MeasurementsContainer;
    /**
     * 
     * @type {MeasurementsContainer}
     * @memberof HourOfDayStats
     */
    '00'?: MeasurementsContainer;
    /**
     * 
     * @type {MeasurementsContainer}
     * @memberof HourOfDayStats
     */
    '01'?: MeasurementsContainer;
    /**
     * 
     * @type {MeasurementsContainer}
     * @memberof HourOfDayStats
     */
    '02'?: MeasurementsContainer;
    /**
     * 
     * @type {MeasurementsContainer}
     * @memberof HourOfDayStats
     */
    '03'?: MeasurementsContainer;
    /**
     * 
     * @type {MeasurementsContainer}
     * @memberof HourOfDayStats
     */
    '04'?: MeasurementsContainer;
    /**
     * 
     * @type {MeasurementsContainer}
     * @memberof HourOfDayStats
     */
    '05'?: MeasurementsContainer;
    /**
     * 
     * @type {MeasurementsContainer}
     * @memberof HourOfDayStats
     */
    '06'?: MeasurementsContainer;
    /**
     * 
     * @type {MeasurementsContainer}
     * @memberof HourOfDayStats
     */
    '07'?: MeasurementsContainer;
    /**
     * 
     * @type {MeasurementsContainer}
     * @memberof HourOfDayStats
     */
    '08'?: MeasurementsContainer;
    /**
     * 
     * @type {MeasurementsContainer}
     * @memberof HourOfDayStats
     */
    '09'?: MeasurementsContainer;
}
/**
 * 
 * @export
 * @interface IdentifyableObject
 */
export interface IdentifyableObject {
    /**
     * Unique ID for the object
     * @type {string}
     * @memberof IdentifyableObject
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface IdentifyableObject1
 */
export interface IdentifyableObject1 {
    /**
     * Unique ID for the object
     * @type {string}
     * @memberof IdentifyableObject1
     */
    'id': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const LimitedOrFullFeature = {
    Full: 'full',
    Limited: 'limited'
} as const;

export type LimitedOrFullFeature = typeof LimitedOrFullFeature[keyof typeof LimitedOrFullFeature];


/**
 * 
 * @export
 * @interface ListApiKeysByAccountId200Response
 */
export interface ListApiKeysByAccountId200Response {
    /**
     * 
     * @type {ListPaginationMeta}
     * @memberof ListApiKeysByAccountId200Response
     */
    'meta'?: ListPaginationMeta;
    /**
     * 
     * @type {ListPaginationLinks}
     * @memberof ListApiKeysByAccountId200Response
     */
    'links'?: ListPaginationLinks;
    /**
     * 
     * @type {Array<ApiKeyItem>}
     * @memberof ListApiKeysByAccountId200Response
     */
    'data'?: Array<ApiKeyItem>;
}
/**
 * 
 * @export
 * @interface ListAudienceDataDailyUsage200Response
 */
export interface ListAudienceDataDailyUsage200Response {
    /**
     * 
     * @type {Array<AudienceDataDailyUsage>}
     * @memberof ListAudienceDataDailyUsage200Response
     */
    'data'?: Array<AudienceDataDailyUsage>;
}
/**
 * 
 * @export
 * @interface ListAudienceDataMonthlyUsage200Response
 */
export interface ListAudienceDataMonthlyUsage200Response {
    /**
     * 
     * @type {Array<AudienceDataMonthlyUsage>}
     * @memberof ListAudienceDataMonthlyUsage200Response
     */
    'data'?: Array<AudienceDataMonthlyUsage>;
}
/**
 * 
 * @export
 * @interface ListAudienceDataRealtimeUsage200Response
 */
export interface ListAudienceDataRealtimeUsage200Response {
    /**
     * 
     * @type {Array<AudienceDataRealtimeUsage>}
     * @memberof ListAudienceDataRealtimeUsage200Response
     */
    'data'?: Array<AudienceDataRealtimeUsage>;
}
/**
 * 
 * @export
 * @interface ListMeasurementClients200Response
 */
export interface ListMeasurementClients200Response {
    /**
     * 
     * @type {Array<MeasurementClientItem>}
     * @memberof ListMeasurementClients200Response
     */
    'data'?: Array<MeasurementClientItem>;
    /**
     * 
     * @type {ListPaginationMeta}
     * @memberof ListMeasurementClients200Response
     */
    'meta'?: ListPaginationMeta;
    /**
     * 
     * @type {ListPaginationLinks}
     * @memberof ListMeasurementClients200Response
     */
    'links'?: ListPaginationLinks;
}
/**
 * 
 * @export
 * @interface ListMeasurementLabels200Response
 */
export interface ListMeasurementLabels200Response {
    /**
     * A set of labels that users can use to categorize their measurements. Can be used to indicate type of study, customer names or other traits. 
     * @type {Array<string>}
     * @memberof ListMeasurementLabels200Response
     */
    'data'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ListPaginationLinks
 */
export interface ListPaginationLinks {
    /**
     * Link to the first page of the list
     * @type {string}
     * @memberof ListPaginationLinks
     */
    'first'?: string;
    /**
     * Link to the next page of the list
     * @type {string}
     * @memberof ListPaginationLinks
     */
    'next'?: string;
}
/**
 * 
 * @export
 * @interface ListPaginationMeta
 */
export interface ListPaginationMeta {
    /**
     * 
     * @type {ListPaginationMetaPage}
     * @memberof ListPaginationMeta
     */
    'page'?: ListPaginationMetaPage;
}
/**
 * 
 * @export
 * @interface ListPaginationMetaPage
 */
export interface ListPaginationMetaPage {
    /**
     * The total amount of elements in the list (the returned `data` may be paginated)
     * @type {number}
     * @memberof ListPaginationMetaPage
     */
    'total'?: number;
    /**
     * 
     * @type {string}
     * @memberof ListPaginationMetaPage
     */
    'first_cursor'?: string;
    /**
     * Indicates the cursor value to use in `page[after]`, when paginating to the next page
     * @type {string}
     * @memberof ListPaginationMetaPage
     */
    'last_cursor'?: string;
    /**
     * Indicates whether the list has been truncated (ie. more items can be queried using pagination)
     * @type {boolean}
     * @memberof ListPaginationMetaPage
     */
    'rangeTruncated': boolean;
}
/**
 * 
 * @export
 * @interface ListPopuplations200Response
 */
export interface ListPopuplations200Response {
    /**
     * 
     * @type {CategoryPopulationsFull}
     * @memberof ListPopuplations200Response
     */
    'data'?: CategoryPopulationsFull;
}
/**
 * 
 * @export
 * @interface ListStudies200Response
 */
export interface ListStudies200Response {
    /**
     * 
     * @type {ListPaginationMeta}
     * @memberof ListStudies200Response
     */
    'meta'?: ListPaginationMeta;
    /**
     * 
     * @type {Array<StudyItem>}
     * @memberof ListStudies200Response
     */
    'data'?: Array<StudyItem>;
    /**
     * 
     * @type {ListPaginationLinks}
     * @memberof ListStudies200Response
     */
    'links'?: ListPaginationLinks;
}
/**
 * 
 * @export
 * @interface ListSubscriptionPlans200Response
 */
export interface ListSubscriptionPlans200Response {
    /**
     * 
     * @type {Array<SubscriptionPlan>}
     * @memberof ListSubscriptionPlans200Response
     */
    'data'?: Array<SubscriptionPlan>;
    /**
     * 
     * @type {ListPaginationMeta}
     * @memberof ListSubscriptionPlans200Response
     */
    'meta'?: ListPaginationMeta;
    /**
     * 
     * @type {ListPaginationLinks}
     * @memberof ListSubscriptionPlans200Response
     */
    'links'?: ListPaginationLinks;
}
/**
 * 
 * @export
 * @interface ListUsersByAccountId200Response
 */
export interface ListUsersByAccountId200Response {
    /**
     * 
     * @type {ListPaginationMeta}
     * @memberof ListUsersByAccountId200Response
     */
    'meta'?: ListPaginationMeta;
    /**
     * 
     * @type {ListPaginationLinks}
     * @memberof ListUsersByAccountId200Response
     */
    'links'?: ListPaginationLinks;
    /**
     * 
     * @type {Array<UserItem>}
     * @memberof ListUsersByAccountId200Response
     */
    'data'?: Array<UserItem>;
}
/**
 * Represents a single measurement
 * @export
 * @interface Measurement
 */
export interface Measurement {
    /**
     * The event that triggered the measurement, typically `impression` or `click`
     * @type {string}
     * @memberof Measurement
     */
    'event': string;
    /**
     * The real value of the measurement, typically a counter value (integer)
     * @type {number}
     * @memberof Measurement
     */
    'count'?: number;
    /**
     * The fraction of events that fall within this object compared to the total of the category or segment (usually represented by the measurement\'s parent\'s parent). For example, if the measurement is \"impression\" on the `home_type` \"Apartment\" object, then the `fraction_of_total` represents the number of impressions on apartments compared to impressions from other `home_type` values. 
     * @type {number}
     * @memberof Measurement
     */
    'fraction_of_total'?: number;
    /**
     * The rate of conversion to this measurement. Typically applies to measurements like \"click\" where it will represent the rate of impressions that turn into a click. 
     * @type {number}
     * @memberof Measurement
     */
    'conversion_rate'?: number;
}
/**
 * 
 * @export
 * @interface MeasurementClientBase
 */
export interface MeasurementClientBase {
    /**
     * The name of the measurement client
     * @type {string}
     * @memberof MeasurementClientBase
     */
    'name'?: string;
    /**
     * The ID of the account that owns this client
     * @type {string}
     * @memberof MeasurementClientBase
     */
    'account_id'?: string;
    /**
     * The URL of an image representing the measurement client
     * @type {string}
     * @memberof MeasurementClientBase
     */
    'logo_url'?: string;
}
/**
 * 
 * @export
 * @interface MeasurementClientFull
 */
export interface MeasurementClientFull {
    /**
     * Unique ID for the object
     * @type {string}
     * @memberof MeasurementClientFull
     */
    'id': string;
    /**
     * The name of the measurement client
     * @type {string}
     * @memberof MeasurementClientFull
     */
    'name'?: string;
    /**
     * The ID of the account that owns this client
     * @type {string}
     * @memberof MeasurementClientFull
     */
    'account_id'?: string;
    /**
     * The URL of an image representing the measurement client
     * @type {string}
     * @memberof MeasurementClientFull
     */
    'logo_url'?: string;
    /**
     * Date and time of the object creation
     * @type {string}
     * @memberof MeasurementClientFull
     */
    'created_at': string;
    /**
     * ID of the user who created the object
     * @type {string}
     * @memberof MeasurementClientFull
     */
    'created_by': string;
    /**
     * Date and time of the latest update to the object
     * @type {string}
     * @memberof MeasurementClientFull
     */
    'updated_at'?: string;
    /**
     * ID of the user who last updated the object
     * @type {string}
     * @memberof MeasurementClientFull
     */
    'updated_by'?: string;
}
/**
 * 
 * @export
 * @interface MeasurementClientItem
 */
export interface MeasurementClientItem {
    /**
     * Unique ID for the object
     * @type {string}
     * @memberof MeasurementClientItem
     */
    'id': string;
    /**
     * The name of the measurement client
     * @type {string}
     * @memberof MeasurementClientItem
     */
    'name'?: string;
    /**
     * The ID of the account that owns this client
     * @type {string}
     * @memberof MeasurementClientItem
     */
    'account_id'?: string;
    /**
     * The URL of an image representing the measurement client
     * @type {string}
     * @memberof MeasurementClientItem
     */
    'logo_url'?: string;
}
/**
 * 
 * @export
 * @interface MeasurementClientMutation
 */
export interface MeasurementClientMutation {
    /**
     * The name of the measurement client
     * @type {string}
     * @memberof MeasurementClientMutation
     */
    'name'?: string;
    /**
     * The ID of the account that owns this client
     * @type {string}
     * @memberof MeasurementClientMutation
     */
    'account_id'?: string;
    /**
     * The URL of an image representing the measurement client
     * @type {string}
     * @memberof MeasurementClientMutation
     */
    'logo_url'?: string;
}
/**
 * 
 * @export
 * @interface MeasurementEventLink
 */
export interface MeasurementEventLink {
    /**
     * The base URI of the link to an event
     * @type {string}
     * @memberof MeasurementEventLink
     */
    'link'?: string;
    /**
     * Describes any parameters that can be added to the event link
     * @type {{ [key: string]: MeasurementEventLinkParameterInfo; }}
     * @memberof MeasurementEventLink
     */
    'parameters'?: { [key: string]: MeasurementEventLinkParameterInfo; };
}
/**
 * 
 * @export
 * @interface MeasurementEventLinkParameterInfo
 */
export interface MeasurementEventLinkParameterInfo {
    /**
     * A description of what the parameter is used for
     * @type {string}
     * @memberof MeasurementEventLinkParameterInfo
     */
    'description'?: string;
}
/**
 * Links to trigger activity and events in this study. Two events are well-known and available in every study: impression and click. 
 * @export
 * @interface MeasurementEventLinks
 */
export interface MeasurementEventLinks {
    [key: string]: MeasurementEventLink | any;

    /**
     * 
     * @type {MeasurementEventLink}
     * @memberof MeasurementEventLinks
     */
    'impression'?: MeasurementEventLink;
    /**
     * 
     * @type {MeasurementEventLink}
     * @memberof MeasurementEventLinks
     */
    'click'?: MeasurementEventLink;
}
/**
 * The set of events to create for the study. 
 * @export
 * @enum {string}
 */

export const MeasurementEventSet = {
    Only: 'impressions_only',
    AndClicks: 'impressions_and_clicks'
} as const;

export type MeasurementEventSet = typeof MeasurementEventSet[keyof typeof MeasurementEventSet];


/**
 * The integration/platform with which a study is being delivered 
 * @export
 * @interface MeasurementIntegrationPlatform
 */
export interface MeasurementIntegrationPlatform {
    /**
     * An ID for the integration platform, if the integration platform is a known platform. Note that integration platform ID uniqueness is a responsibility of the client since this is simply an optional reference point to keep. Can be null/omitted if the platform name is a one-off value with just a string. 
     * @type {string}
     * @memberof MeasurementIntegrationPlatform
     */
    'id'?: string;
    /**
     * The name of the integration platform.
     * @type {string}
     * @memberof MeasurementIntegrationPlatform
     */
    'name'?: string;
}
/**
 * An object containing measurements
 * @export
 * @interface MeasurementsContainer
 */
export interface MeasurementsContainer {
    /**
     * Measurements related to this object
     * @type {Array<Measurement>}
     * @memberof MeasurementsContainer
     */
    'measurements': Array<Measurement>;
}
/**
 * 
 * @export
 * @interface PasswordlessAuthRequest
 */
export interface PasswordlessAuthRequest {
    /**
     * The email of the user
     * @type {string}
     * @memberof PasswordlessAuthRequest
     */
    'email': string;
}
/**
 * Defines the scopes of a token or API key. If omitted, the default set of grants that are available to non-admin and non-owner users of the account will be added.
 * @export
 * @interface PermissionScopes
 */
export interface PermissionScopes {
    /**
     * A list of origin domains that will be allowed access through CORS and Referrer checks with the token or API key. A missing value, empty array or the value `*` grants access from any domain.
     * @type {Array<string>}
     * @memberof PermissionScopes
     */
    'origin_domains'?: Array<string>;
    /**
     * A list of service grants to allow access to use. A missing value, empty array or the value `*` grants access to all of the services that are available to non-admin and non-owner users of the account.
     * @type {Array<string>}
     * @memberof PermissionScopes
     */
    'service_grants'?: Array<string>;
    /**
     * A list of country-specific data sources to allow access to. A missing value, empty array or the value `*` grants access to any data source.
     * @type {Array<string>}
     * @memberof PermissionScopes
     */
    'country_data'?: Array<string>;
}
/**
 * 
 * @export
 * @interface PlanFeatureSet
 */
export interface PlanFeatureSet {
    /**
     * 
     * @type {number}
     * @memberof PlanFeatureSet
     */
    'max_users': number;
    /**
     * 
     * @type {number}
     * @memberof PlanFeatureSet
     */
    'max_clients': number;
    /**
     * 
     * @type {number}
     * @memberof PlanFeatureSet
     */
    'max_active_studies': number;
    /**
     * 
     * @type {number}
     * @memberof PlanFeatureSet
     */
    'max_events_per_study': number;
    /**
     * 
     * @type {number}
     * @memberof PlanFeatureSet
     */
    'max_audience_lookups_per_month': number;
    /**
     * 
     * @type {LimitedOrFullFeature}
     * @memberof PlanFeatureSet
     */
    'study_audience_set': LimitedOrFullFeature;
    /**
     * 
     * @type {LimitedOrFullFeature}
     * @memberof PlanFeatureSet
     */
    'study_event_set': LimitedOrFullFeature;
    /**
     * 
     * @type {boolean}
     * @memberof PlanFeatureSet
     */
    'has_audience_recommendations': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PlanFeatureSet
     */
    'has_report_customization': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PlanFeatureSet
     */
    'has_report_sharing_clients': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PlanFeatureSet
     */
    'has_report_sharing_public': boolean;
}


/**
 * 
 * @export
 * @interface PopulationAudienceCategorySetBusinessSection
 */
export interface PopulationAudienceCategorySetBusinessSection {
    /**
     * The fraction of events that fall within this object compared to the total of the category or segment (usually represented by the measurement\'s parent\'s parent). For example, if the measurement is \"impression\" on the `home_type` \"Apartment\" object, then the `fraction_of_total` represents the number of impressions on apartments compared to impressions from other `home_type` values. 
     * @type {number}
     * @memberof PopulationAudienceCategorySetBusinessSection
     */
    'fraction_of_total'?: number;
    /**
     * An object with category codes as keys, objects with audience codes and fractions of totals as keys.
     * @type {{ [key: string]: { [key: string]: number; }; }}
     * @memberof PopulationAudienceCategorySetBusinessSection
     */
    'audience_categories'?: { [key: string]: { [key: string]: number; }; };
}
/**
 * 
 * @export
 * @interface PopulationAudienceCategorySetPrivateSection
 */
export interface PopulationAudienceCategorySetPrivateSection {
    /**
     * The fraction of events that fall within this object compared to the total of the category or segment (usually represented by the measurement\'s parent\'s parent). For example, if the measurement is \"impression\" on the `home_type` \"Apartment\" object, then the `fraction_of_total` represents the number of impressions on apartments compared to impressions from other `home_type` values. 
     * @type {number}
     * @memberof PopulationAudienceCategorySetPrivateSection
     */
    'fraction_of_total'?: number;
    /**
     * An object with category codes as keys, objects with audience codes and fractions of totals as keys.
     * @type {{ [key: string]: { [key: string]: number; }; }}
     * @memberof PopulationAudienceCategorySetPrivateSection
     */
    'audience_categories'?: { [key: string]: { [key: string]: number; }; };
}
/**
 * 
 * @export
 * @interface PopulationAudienceCategorySetSection
 */
export interface PopulationAudienceCategorySetSection {
    /**
     * The fraction of events that fall within this object compared to the total of the category or segment (usually represented by the measurement\'s parent\'s parent). For example, if the measurement is \"impression\" on the `home_type` \"Apartment\" object, then the `fraction_of_total` represents the number of impressions on apartments compared to impressions from other `home_type` values. 
     * @type {number}
     * @memberof PopulationAudienceCategorySetSection
     */
    'fraction_of_total'?: number;
    /**
     * An object with category codes as keys, objects with audience codes and fractions of totals as keys.
     * @type {{ [key: string]: { [key: string]: number; }; }}
     * @memberof PopulationAudienceCategorySetSection
     */
    'audience_categories'?: { [key: string]: { [key: string]: number; }; };
}
/**
 * Describes the audience composition of a population. Every metric is delivered in relative measures (ie. fractions of total rather than counts) to make enable the comparison or adjustment of populations. 
 * @export
 * @interface PopulationFull
 */
export interface PopulationFull {
    /**
     * A humanly readable name of the population
     * @type {string}
     * @memberof PopulationFull
     */
    'name'?: string;
    /**
     * 
     * @type {PopulationAudienceCategorySetPrivateSection}
     * @memberof PopulationFull
     */
    'private'?: PopulationAudienceCategorySetPrivateSection;
    /**
     * 
     * @type {PopulationAudienceCategorySetBusinessSection}
     * @memberof PopulationFull
     */
    'business'?: PopulationAudienceCategorySetBusinessSection;
}
/**
 * 
 * @export
 * @interface PopulationItem
 */
export interface PopulationItem {
    /**
     * A unique key for the population
     * @type {string}
     * @memberof PopulationItem
     */
    'key': string;
}
/**
 * Source data for a population
 * @export
 * @interface PopulationSource
 */
export interface PopulationSource {
    /**
     * A humanly readable name of the population
     * @type {string}
     * @memberof PopulationSource
     */
    'name': string;
    /**
     * Name or description of the data source
     * @type {string}
     * @memberof PopulationSource
     */
    'source': string;
    /**
     * 
     * @type {object}
     * @memberof PopulationSource
     */
    'meta': object;
    /**
     * 
     * @type {PopulationSourceNotResolvedSection}
     * @memberof PopulationSource
     */
    'not_resolved'?: PopulationSourceNotResolvedSection;
    /**
     * 
     * @type {PopulationSourcePrivateSection}
     * @memberof PopulationSource
     */
    'private': PopulationSourcePrivateSection;
    /**
     * 
     * @type {PopulationSourceBusinessSection}
     * @memberof PopulationSource
     */
    'business': PopulationSourceBusinessSection;
}
/**
 * 
 * @export
 * @interface PopulationSourceBusinessCategorySet
 */
export interface PopulationSourceBusinessCategorySet {
    /**
     * 
     * @type {PopulationSourceBusinessCategorySetSize}
     * @memberof PopulationSourceBusinessCategorySet
     */
    'size': PopulationSourceBusinessCategorySetSize;
}
/**
 * 
 * @export
 * @interface PopulationSourceBusinessCategorySetSize
 */
export interface PopulationSourceBusinessCategorySetSize {
    /**
     * 
     * @type {number}
     * @memberof PopulationSourceBusinessCategorySetSize
     */
    'ba1': number;
    /**
     * 
     * @type {number}
     * @memberof PopulationSourceBusinessCategorySetSize
     */
    'ba2': number;
    /**
     * 
     * @type {number}
     * @memberof PopulationSourceBusinessCategorySetSize
     */
    'ba3': number;
}
/**
 * 
 * @export
 * @interface PopulationSourceBusinessSection
 */
export interface PopulationSourceBusinessSection {
    /**
     * 
     * @type {PopulationSourceBusinessCategorySet}
     * @memberof PopulationSourceBusinessSection
     */
    'audience_categories'?: PopulationSourceBusinessCategorySet;
    /**
     * 
     * @type {number}
     * @memberof PopulationSourceBusinessSection
     */
    'count'?: number;
}
/**
 * 
 * @export
 * @interface PopulationSourceNotResolvedSection
 */
export interface PopulationSourceNotResolvedSection {
    /**
     * 
     * @type {number}
     * @memberof PopulationSourceNotResolvedSection
     */
    'count'?: number;
}
/**
 * 
 * @export
 * @interface PopulationSourcePrivateCategorySet
 */
export interface PopulationSourcePrivateCategorySet {
    /**
     * 
     * @type {PopulationSourcePrivateCategorySetHomeType}
     * @memberof PopulationSourcePrivateCategorySet
     */
    'home_type': PopulationSourcePrivateCategorySetHomeType;
    /**
     * 
     * @type {PopulationSourcePrivateCategorySetSavings}
     * @memberof PopulationSourcePrivateCategorySet
     */
    'savings': PopulationSourcePrivateCategorySetSavings;
    /**
     * 
     * @type {PopulationSourcePrivateCategorySetLifecycle}
     * @memberof PopulationSourcePrivateCategorySet
     */
    'lifecycle': PopulationSourcePrivateCategorySetLifecycle;
    /**
     * 
     * @type {PopulationSourcePrivateCategorySetCars}
     * @memberof PopulationSourcePrivateCategorySet
     */
    'cars': PopulationSourcePrivateCategorySetCars;
    /**
     * 
     * @type {PopulationSourcePrivateCategorySetChildren}
     * @memberof PopulationSourcePrivateCategorySet
     */
    'children': PopulationSourcePrivateCategorySetChildren;
    /**
     * 
     * @type {PopulationSourcePrivateCategorySetEducation}
     * @memberof PopulationSourcePrivateCategorySet
     */
    'education': PopulationSourcePrivateCategorySetEducation;
    /**
     * 
     * @type {PopulationSourcePrivateCategorySetNeighbourhoodType}
     * @memberof PopulationSourcePrivateCategorySet
     */
    'neighbourhood_type': PopulationSourcePrivateCategorySetNeighbourhoodType;
    /**
     * 
     * @type {PopulationSourcePrivateCategorySetIncome}
     * @memberof PopulationSourcePrivateCategorySet
     */
    'income': PopulationSourcePrivateCategorySetIncome;
    /**
     * 
     * @type {PopulationSourcePrivateCategorySetHomeOwnership}
     * @memberof PopulationSourcePrivateCategorySet
     */
    'home_ownership': PopulationSourcePrivateCategorySetHomeOwnership;
    /**
     * 
     * @type {PopulationSourcePrivateCategorySetBuildingAge}
     * @memberof PopulationSourcePrivateCategorySet
     */
    'building_age': PopulationSourcePrivateCategorySetBuildingAge;
    /**
     * 
     * @type {PopulationSourcePrivateCategorySetLivingSpace}
     * @memberof PopulationSourcePrivateCategorySet
     */
    'living_space': PopulationSourcePrivateCategorySetLivingSpace;
    /**
     * 
     * @type {PopulationSourcePrivateCategorySetTechLevel}
     * @memberof PopulationSourcePrivateCategorySet
     */
    'tech_level': PopulationSourcePrivateCategorySetTechLevel;
}
/**
 * 
 * @export
 * @interface PopulationSourcePrivateCategorySetBuildingAge
 */
export interface PopulationSourcePrivateCategorySetBuildingAge {
    /**
     * 
     * @type {number}
     * @memberof PopulationSourcePrivateCategorySetBuildingAge
     */
    'k1': number;
    /**
     * 
     * @type {number}
     * @memberof PopulationSourcePrivateCategorySetBuildingAge
     */
    'k2': number;
    /**
     * 
     * @type {number}
     * @memberof PopulationSourcePrivateCategorySetBuildingAge
     */
    'k3': number;
}
/**
 * 
 * @export
 * @interface PopulationSourcePrivateCategorySetCars
 */
export interface PopulationSourcePrivateCategorySetCars {
    /**
     * 
     * @type {number}
     * @memberof PopulationSourcePrivateCategorySetCars
     */
    'd1': number;
    /**
     * 
     * @type {number}
     * @memberof PopulationSourcePrivateCategorySetCars
     */
    'd2': number;
    /**
     * 
     * @type {number}
     * @memberof PopulationSourcePrivateCategorySetCars
     */
    'd3': number;
}
/**
 * 
 * @export
 * @interface PopulationSourcePrivateCategorySetChildren
 */
export interface PopulationSourcePrivateCategorySetChildren {
    /**
     * 
     * @type {number}
     * @memberof PopulationSourcePrivateCategorySetChildren
     */
    'e1': number;
    /**
     * 
     * @type {number}
     * @memberof PopulationSourcePrivateCategorySetChildren
     */
    'e2': number;
    /**
     * 
     * @type {number}
     * @memberof PopulationSourcePrivateCategorySetChildren
     */
    'e3': number;
}
/**
 * 
 * @export
 * @interface PopulationSourcePrivateCategorySetEducation
 */
export interface PopulationSourcePrivateCategorySetEducation {
    /**
     * 
     * @type {number}
     * @memberof PopulationSourcePrivateCategorySetEducation
     */
    'f1': number;
    /**
     * 
     * @type {number}
     * @memberof PopulationSourcePrivateCategorySetEducation
     */
    'f2': number;
    /**
     * 
     * @type {number}
     * @memberof PopulationSourcePrivateCategorySetEducation
     */
    'f3': number;
}
/**
 * 
 * @export
 * @interface PopulationSourcePrivateCategorySetHomeOwnership
 */
export interface PopulationSourcePrivateCategorySetHomeOwnership {
    /**
     * 
     * @type {number}
     * @memberof PopulationSourcePrivateCategorySetHomeOwnership
     */
    'j1': number;
    /**
     * 
     * @type {number}
     * @memberof PopulationSourcePrivateCategorySetHomeOwnership
     */
    'j2': number;
}
/**
 * 
 * @export
 * @interface PopulationSourcePrivateCategorySetHomeType
 */
export interface PopulationSourcePrivateCategorySetHomeType {
    /**
     * 
     * @type {number}
     * @memberof PopulationSourcePrivateCategorySetHomeType
     */
    'a1': number;
    /**
     * 
     * @type {number}
     * @memberof PopulationSourcePrivateCategorySetHomeType
     */
    'a2': number;
}
/**
 * 
 * @export
 * @interface PopulationSourcePrivateCategorySetIncome
 */
export interface PopulationSourcePrivateCategorySetIncome {
    /**
     * 
     * @type {number}
     * @memberof PopulationSourcePrivateCategorySetIncome
     */
    'h1': number;
    /**
     * 
     * @type {number}
     * @memberof PopulationSourcePrivateCategorySetIncome
     */
    'h2': number;
    /**
     * 
     * @type {number}
     * @memberof PopulationSourcePrivateCategorySetIncome
     */
    'h3': number;
    /**
     * 
     * @type {number}
     * @memberof PopulationSourcePrivateCategorySetIncome
     */
    'h4': number;
    /**
     * 
     * @type {number}
     * @memberof PopulationSourcePrivateCategorySetIncome
     */
    'h5': number;
}
/**
 * 
 * @export
 * @interface PopulationSourcePrivateCategorySetLifecycle
 */
export interface PopulationSourcePrivateCategorySetLifecycle {
    /**
     * 
     * @type {number}
     * @memberof PopulationSourcePrivateCategorySetLifecycle
     */
    'c1': number;
    /**
     * 
     * @type {number}
     * @memberof PopulationSourcePrivateCategorySetLifecycle
     */
    'c2': number;
    /**
     * 
     * @type {number}
     * @memberof PopulationSourcePrivateCategorySetLifecycle
     */
    'c3': number;
    /**
     * 
     * @type {number}
     * @memberof PopulationSourcePrivateCategorySetLifecycle
     */
    'c4': number;
    /**
     * 
     * @type {number}
     * @memberof PopulationSourcePrivateCategorySetLifecycle
     */
    'c5': number;
}
/**
 * 
 * @export
 * @interface PopulationSourcePrivateCategorySetLivingSpace
 */
export interface PopulationSourcePrivateCategorySetLivingSpace {
    /**
     * 
     * @type {number}
     * @memberof PopulationSourcePrivateCategorySetLivingSpace
     */
    'l1': number;
    /**
     * 
     * @type {number}
     * @memberof PopulationSourcePrivateCategorySetLivingSpace
     */
    'l2': number;
    /**
     * 
     * @type {number}
     * @memberof PopulationSourcePrivateCategorySetLivingSpace
     */
    'l3': number;
}
/**
 * 
 * @export
 * @interface PopulationSourcePrivateCategorySetNeighbourhoodType
 */
export interface PopulationSourcePrivateCategorySetNeighbourhoodType {
    /**
     * 
     * @type {number}
     * @memberof PopulationSourcePrivateCategorySetNeighbourhoodType
     */
    'g1': number;
    /**
     * 
     * @type {number}
     * @memberof PopulationSourcePrivateCategorySetNeighbourhoodType
     */
    'g2': number;
    /**
     * 
     * @type {number}
     * @memberof PopulationSourcePrivateCategorySetNeighbourhoodType
     */
    'g3': number;
    /**
     * 
     * @type {number}
     * @memberof PopulationSourcePrivateCategorySetNeighbourhoodType
     */
    'g4': number;
}
/**
 * 
 * @export
 * @interface PopulationSourcePrivateCategorySetSavings
 */
export interface PopulationSourcePrivateCategorySetSavings {
    /**
     * 
     * @type {number}
     * @memberof PopulationSourcePrivateCategorySetSavings
     */
    'b1': number;
    /**
     * 
     * @type {number}
     * @memberof PopulationSourcePrivateCategorySetSavings
     */
    'b2': number;
    /**
     * 
     * @type {number}
     * @memberof PopulationSourcePrivateCategorySetSavings
     */
    'b3': number;
}
/**
 * 
 * @export
 * @interface PopulationSourcePrivateCategorySetTechLevel
 */
export interface PopulationSourcePrivateCategorySetTechLevel {
    /**
     * 
     * @type {number}
     * @memberof PopulationSourcePrivateCategorySetTechLevel
     */
    'n1': number;
    /**
     * 
     * @type {number}
     * @memberof PopulationSourcePrivateCategorySetTechLevel
     */
    'n2': number;
    /**
     * 
     * @type {number}
     * @memberof PopulationSourcePrivateCategorySetTechLevel
     */
    'n3': number;
}
/**
 * 
 * @export
 * @interface PopulationSourcePrivateSection
 */
export interface PopulationSourcePrivateSection {
    /**
     * 
     * @type {PopulationSourcePrivateCategorySet}
     * @memberof PopulationSourcePrivateSection
     */
    'audience_categories'?: PopulationSourcePrivateCategorySet;
    /**
     * 
     * @type {number}
     * @memberof PopulationSourcePrivateSection
     */
    'count'?: number;
}
/**
 * 
 * @export
 * @interface PostalAddress
 */
export interface PostalAddress {
    /**
     * The first line of the postal address
     * @type {string}
     * @memberof PostalAddress
     */
    'line1'?: string;
    /**
     * The second line of the postal address
     * @type {string}
     * @memberof PostalAddress
     */
    'line2'?: string;
    /**
     * The city of the billing address
     * @type {string}
     * @memberof PostalAddress
     */
    'city'?: string;
    /**
     * The postal code of the billing address
     * @type {string}
     * @memberof PostalAddress
     */
    'postal_code'?: string;
    /**
     * The state of the billing address
     * @type {string}
     * @memberof PostalAddress
     */
    'state'?: string;
}
/**
 * Measurements (overall and per audience) for traffic resolved as private users
 * @export
 * @interface PrivateAudienceStats
 */
export interface PrivateAudienceStats {
    /**
     * Measurements related to this object
     * @type {Array<Measurement>}
     * @memberof PrivateAudienceStats
     */
    'measurements': Array<Measurement>;
    /**
     * 
     * @type {PrivateAudienceStatsAudienceCategories}
     * @memberof PrivateAudienceStats
     */
    'audience_categories': PrivateAudienceStatsAudienceCategories;
}
/**
 * 
 * @export
 * @interface PrivateAudienceStatsAudienceCategories
 */
export interface PrivateAudienceStatsAudienceCategories {
    /**
     * 
     * @type {AudienceCategoryStats}
     * @memberof PrivateAudienceStatsAudienceCategories
     */
    'home_type': AudienceCategoryStats;
    /**
     * 
     * @type {AudienceCategoryStats}
     * @memberof PrivateAudienceStatsAudienceCategories
     */
    'savings': AudienceCategoryStats;
    /**
     * 
     * @type {AudienceCategoryStats}
     * @memberof PrivateAudienceStatsAudienceCategories
     */
    'lifecycle': AudienceCategoryStats;
    /**
     * 
     * @type {AudienceCategoryStats}
     * @memberof PrivateAudienceStatsAudienceCategories
     */
    'cars': AudienceCategoryStats;
    /**
     * 
     * @type {AudienceCategoryStats}
     * @memberof PrivateAudienceStatsAudienceCategories
     */
    'children': AudienceCategoryStats;
    /**
     * 
     * @type {AudienceCategoryStats}
     * @memberof PrivateAudienceStatsAudienceCategories
     */
    'education': AudienceCategoryStats;
    /**
     * 
     * @type {AudienceCategoryStats}
     * @memberof PrivateAudienceStatsAudienceCategories
     */
    'neighbourhood_type': AudienceCategoryStats;
    /**
     * 
     * @type {AudienceCategoryStats}
     * @memberof PrivateAudienceStatsAudienceCategories
     */
    'income': AudienceCategoryStats;
    /**
     * 
     * @type {AudienceCategoryStats}
     * @memberof PrivateAudienceStatsAudienceCategories
     */
    'home_ownership': AudienceCategoryStats;
    /**
     * 
     * @type {AudienceCategoryStats}
     * @memberof PrivateAudienceStatsAudienceCategories
     */
    'building_age': AudienceCategoryStats;
    /**
     * 
     * @type {AudienceCategoryStats}
     * @memberof PrivateAudienceStatsAudienceCategories
     */
    'living_space': AudienceCategoryStats;
    /**
     * 
     * @type {AudienceCategoryStats}
     * @memberof PrivateAudienceStatsAudienceCategories
     */
    'tech_level': AudienceCategoryStats;
}
/**
 * 
 * @export
 * @interface QueryStudyAudienceStats200Response
 */
export interface QueryStudyAudienceStats200Response {
    /**
     * 
     * @type {StudyAudienceStats}
     * @memberof QueryStudyAudienceStats200Response
     */
    'data'?: StudyAudienceStats;
}
/**
 * 
 * @export
 * @interface QueryStudyCountryStats200Response
 */
export interface QueryStudyCountryStats200Response {
    /**
     * 
     * @type {StudyCountryStats}
     * @memberof QueryStudyCountryStats200Response
     */
    'data'?: StudyCountryStats;
}
/**
 * 
 * @export
 * @interface QueryStudyFrequencyStats200Response
 */
export interface QueryStudyFrequencyStats200Response {
    /**
     * 
     * @type {StudyFrequencyStats}
     * @memberof QueryStudyFrequencyStats200Response
     */
    'data'?: StudyFrequencyStats;
}
/**
 * 
 * @export
 * @interface QueryStudyTimingStats200Response
 */
export interface QueryStudyTimingStats200Response {
    /**
     * 
     * @type {StudyTimingStats}
     * @memberof QueryStudyTimingStats200Response
     */
    'data'?: StudyTimingStats;
}
/**
 * 
 * @export
 * @interface RegistrationByIdResponseData
 */
export interface RegistrationByIdResponseData {
    /**
     * The ID of the registration
     * @type {string}
     * @memberof RegistrationByIdResponseData
     */
    'id'?: string;
    /**
     * 
     * @type {RegistrationRequest}
     * @memberof RegistrationByIdResponseData
     */
    'request'?: RegistrationRequest;
    /**
     * Date and time of the registration expiry
     * @type {string}
     * @memberof RegistrationByIdResponseData
     */
    'expires_at'?: string;
    /**
     * Date and time of the verification, if verified
     * @type {string}
     * @memberof RegistrationByIdResponseData
     */
    'verified_at'?: string;
    /**
     * The code needed to verify this registration
     * @type {string}
     * @memberof RegistrationByIdResponseData
     */
    'verification_code'?: string;
}
/**
 * 
 * @export
 * @interface RegistrationCreationResponseData
 */
export interface RegistrationCreationResponseData {
    /**
     * 
     * @type {string}
     * @memberof RegistrationCreationResponseData
     */
    'id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof RegistrationCreationResponseData
     */
    'email_sent'?: boolean;
}
/**
 * 
 * @export
 * @interface RegistrationRequest
 */
export interface RegistrationRequest {
    /**
     * The name of the account to create
     * @type {string}
     * @memberof RegistrationRequest
     */
    'account_name': string;
    /**
     * The email of the account owner
     * @type {string}
     * @memberof RegistrationRequest
     */
    'owner_email': string;
    /**
     * The name of the account owner
     * @type {string}
     * @memberof RegistrationRequest
     */
    'owner_name': string;
}
/**
 * 
 * @export
 * @interface RegistrationVerificationResponseData
 */
export interface RegistrationVerificationResponseData {
    /**
     * A short-lived token (usable for 1 hour) to be used in subsequent requests
     * @type {string}
     * @memberof RegistrationVerificationResponseData
     */
    'access_token': string;
    /**
     * The type of access token returned
     * @type {string}
     * @memberof RegistrationVerificationResponseData
     */
    'token_type': string;
    /**
     * The duration of time (in seconds) the access token is granted for
     * @type {number}
     * @memberof RegistrationVerificationResponseData
     */
    'expires_in': number;
    /**
     * A long-lived token that can be used to generate new access tokens even after the returned access token expires.
     * @type {string}
     * @memberof RegistrationVerificationResponseData
     */
    'refresh_token'?: string;
}
/**
 * 
 * @export
 * @interface RegistrationVerificationResponseLinks
 */
export interface RegistrationVerificationResponseLinks {
    /**
     * Link of the created user
     * @type {string}
     * @memberof RegistrationVerificationResponseLinks
     */
    'user'?: string;
    /**
     * Link of the created account
     * @type {string}
     * @memberof RegistrationVerificationResponseLinks
     */
    'account'?: string;
}
/**
 * 
 * @export
 * @interface ResolveAudiencesOfMultipleRequest
 */
export interface ResolveAudiencesOfMultipleRequest {
    /**
     * 
     * @type {Array<ResolveAudiencesOfMultipleRequestItem>}
     * @memberof ResolveAudiencesOfMultipleRequest
     */
    'queries': Array<ResolveAudiencesOfMultipleRequestItem>;
}
/**
 * 
 * @export
 * @interface ResolveAudiencesOfMultipleRequestItem
 */
export interface ResolveAudiencesOfMultipleRequestItem {
    /**
     * An optional identifier for the item. The identifier will also be available in the response.
     * @type {string}
     * @memberof ResolveAudiencesOfMultipleRequestItem
     */
    'id'?: string;
    /**
     * The IP address to resolve audiences for
     * @type {string}
     * @memberof ResolveAudiencesOfMultipleRequestItem
     */
    'ip_address': string;
}
/**
 * 
 * @export
 * @interface ResolveAudiencesOfMultipleResponse
 */
export interface ResolveAudiencesOfMultipleResponse {
    /**
     * 
     * @type {Array<ResolveAudiencesOfMultipleResponseItem>}
     * @memberof ResolveAudiencesOfMultipleResponse
     */
    'results'?: Array<ResolveAudiencesOfMultipleResponseItem>;
}
/**
 * 
 * @export
 * @interface ResolveAudiencesOfMultipleResponseItem
 */
export interface ResolveAudiencesOfMultipleResponseItem {
    /**
     * The identifier (if provided) of the item as it was provided in the request.
     * @type {string}
     * @memberof ResolveAudiencesOfMultipleResponseItem
     */
    'id'?: string;
    /**
     * 
     * @type {Array<Audience>}
     * @memberof ResolveAudiencesOfMultipleResponseItem
     */
    'audiences'?: Array<Audience>;
    /**
     * 
     * @type {AudienceResponseStatus}
     * @memberof ResolveAudiencesOfMultipleResponseItem
     */
    'status': AudienceResponseStatus;
}


/**
 * 
 * @export
 * @interface StudyAudienceStats
 */
export interface StudyAudienceStats {
    /**
     * 
     * @type {MeasurementsContainer}
     * @memberof StudyAudienceStats
     */
    'not_resolved'?: MeasurementsContainer;
    /**
     * 
     * @type {BusinessAudienceStats}
     * @memberof StudyAudienceStats
     */
    'business'?: BusinessAudienceStats;
    /**
     * 
     * @type {PrivateAudienceStats}
     * @memberof StudyAudienceStats
     */
    'private'?: PrivateAudienceStats;
}
/**
 * 
 * @export
 * @interface StudyAux
 */
export interface StudyAux {
    /**
     * 
     * @type {MeasurementEventLinks}
     * @memberof StudyAux
     */
    'event_links'?: MeasurementEventLinks;
    /**
     * The URL to a banner image for the study. Note that the banner image is used only for Digiseg study reporting and presentation, it does NOT represent any delivered banner ad creatives or similar. 
     * @type {string}
     * @memberof StudyAux
     */
    'banner_image_url'?: string;
    /**
     * 
     * @type {MeasurementIntegrationPlatform}
     * @memberof StudyAux
     */
    'integration_platform'?: MeasurementIntegrationPlatform;
    /**
     * Determines if the study is an example study, used to demonstrate product capabilities
     * @type {boolean}
     * @memberof StudyAux
     */
    'is_example'?: boolean;
}
/**
 * 
 * @export
 * @interface StudyBase
 */
export interface StudyBase {
    /**
     * 
     * @type {string}
     * @memberof StudyBase
     */
    'name'?: string;
    /**
     * A set of labels that users can use to categorize their measurements. Can be used to indicate type of study, customer names or other traits. 
     * @type {Array<string>}
     * @memberof StudyBase
     */
    'labels'?: Array<string>;
    /**
     * The ID of the account that owns this study
     * @type {string}
     * @memberof StudyBase
     */
    'account_id'?: string;
    /**
     * The date for which the study and its data ingestion will start
     * @type {string}
     * @memberof StudyBase
     */
    'start_date'?: string;
    /**
     * 
     * @type {StudyLifecycleStage}
     * @memberof StudyBase
     */
    'life_cycle_stage'?: StudyLifecycleStage;
    /**
     * 
     * @type {StudyIngestionStatus}
     * @memberof StudyBase
     */
    'ingestion_status'?: StudyIngestionStatus;
    /**
     * 
     * @type {StudySummaryStats}
     * @memberof StudyBase
     */
    'summary_stats'?: StudySummaryStats;
    /**
     * 
     * @type {MeasurementClientItem}
     * @memberof StudyBase
     */
    'client'?: MeasurementClientItem;
}


/**
 * 
 * @export
 * @interface StudyCountryStats
 */
export interface StudyCountryStats {
    /**
     * The country code of the predominant country of the study
     * @type {string}
     * @memberof StudyCountryStats
     */
    'predominant_country'?: string;
    /**
     * A listing of each countries observed and the relevant measurements for each
     * @type {Array<CountryStats>}
     * @memberof StudyCountryStats
     */
    'countries'?: Array<CountryStats>;
    /**
     * 
     * @type {MeasurementsContainer}
     * @memberof StudyCountryStats
     */
    'resolved'?: MeasurementsContainer;
    /**
     * 
     * @type {MeasurementsContainer}
     * @memberof StudyCountryStats
     */
    'not_resolved'?: MeasurementsContainer;
}
/**
 * 
 * @export
 * @interface StudyCreation
 */
export interface StudyCreation {
    /**
     * 
     * @type {string}
     * @memberof StudyCreation
     */
    'name': string;
    /**
     * A set of labels that users can use to categorize their measurements. Can be used to indicate type of study, customer names or other traits. 
     * @type {Array<string>}
     * @memberof StudyCreation
     */
    'labels'?: Array<string>;
    /**
     * The ID of the account that owns this study
     * @type {string}
     * @memberof StudyCreation
     */
    'account_id'?: string;
    /**
     * The date for which the study and its data ingestion will start
     * @type {string}
     * @memberof StudyCreation
     */
    'start_date'?: string;
    /**
     * 
     * @type {StudyLifecycleStage}
     * @memberof StudyCreation
     */
    'life_cycle_stage'?: StudyLifecycleStage;
    /**
     * 
     * @type {StudyIngestionStatus}
     * @memberof StudyCreation
     */
    'ingestion_status'?: StudyIngestionStatus;
    /**
     * 
     * @type {StudySummaryStats}
     * @memberof StudyCreation
     */
    'summary_stats'?: StudySummaryStats;
    /**
     * 
     * @type {MeasurementClientItem}
     * @memberof StudyCreation
     */
    'client'?: MeasurementClientItem;
    /**
     * 
     * @type {MeasurementEventLinks}
     * @memberof StudyCreation
     */
    'event_links'?: MeasurementEventLinks;
    /**
     * The URL to a banner image for the study. Note that the banner image is used only for Digiseg study reporting and presentation, it does NOT represent any delivered banner ad creatives or similar. 
     * @type {string}
     * @memberof StudyCreation
     */
    'banner_image_url'?: string;
    /**
     * 
     * @type {MeasurementIntegrationPlatform}
     * @memberof StudyCreation
     */
    'integration_platform'?: MeasurementIntegrationPlatform;
    /**
     * Determines if the study is an example study, used to demonstrate product capabilities
     * @type {boolean}
     * @memberof StudyCreation
     */
    'is_example'?: boolean;
    /**
     * 
     * @type {MeasurementEventSet}
     * @memberof StudyCreation
     */
    'event_set': MeasurementEventSet;
    /**
     * The ID of the measurement client that this study is for
     * @type {string}
     * @memberof StudyCreation
     */
    'client_id'?: string;
}


/**
 * 
 * @export
 * @interface StudyCreationData
 */
export interface StudyCreationData {
    /**
     * 
     * @type {MeasurementEventSet}
     * @memberof StudyCreationData
     */
    'event_set': MeasurementEventSet;
    /**
     * The ID of the measurement client that this study is for
     * @type {string}
     * @memberof StudyCreationData
     */
    'client_id'?: string;
}


/**
 * 
 * @export
 * @interface StudyFrequencyStats
 */
export interface StudyFrequencyStats {
    /**
     * The average frequency of impressions per user. 
     * @type {number}
     * @memberof StudyFrequencyStats
     */
    'average_frequency'?: number;
    /**
     * A listing of frequencies observed and the relevant measurements for each. The returned list may be truncated to cut off the \"long tail\" of frequency values. 
     * @type {Array<FrequencyStats>}
     * @memberof StudyFrequencyStats
     */
    'frequencies'?: Array<FrequencyStats>;
    /**
     * The number of users that have generated impressions at a frequency value greater than those represented in `frequencies`. 
     * @type {number}
     * @memberof StudyFrequencyStats
     */
    'count_above_cap'?: number;
}
/**
 * 
 * @export
 * @interface StudyFull
 */
export interface StudyFull {
    /**
     * Unique ID for the object
     * @type {string}
     * @memberof StudyFull
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof StudyFull
     */
    'name'?: string;
    /**
     * A set of labels that users can use to categorize their measurements. Can be used to indicate type of study, customer names or other traits. 
     * @type {Array<string>}
     * @memberof StudyFull
     */
    'labels'?: Array<string>;
    /**
     * The ID of the account that owns this study
     * @type {string}
     * @memberof StudyFull
     */
    'account_id'?: string;
    /**
     * The date for which the study and its data ingestion will start
     * @type {string}
     * @memberof StudyFull
     */
    'start_date'?: string;
    /**
     * 
     * @type {StudyLifecycleStage}
     * @memberof StudyFull
     */
    'life_cycle_stage'?: StudyLifecycleStage;
    /**
     * 
     * @type {StudyIngestionStatus}
     * @memberof StudyFull
     */
    'ingestion_status'?: StudyIngestionStatus;
    /**
     * 
     * @type {StudySummaryStats}
     * @memberof StudyFull
     */
    'summary_stats'?: StudySummaryStats;
    /**
     * 
     * @type {MeasurementClientItem}
     * @memberof StudyFull
     */
    'client'?: MeasurementClientItem;
    /**
     * 
     * @type {MeasurementEventLinks}
     * @memberof StudyFull
     */
    'event_links'?: MeasurementEventLinks;
    /**
     * The URL to a banner image for the study. Note that the banner image is used only for Digiseg study reporting and presentation, it does NOT represent any delivered banner ad creatives or similar. 
     * @type {string}
     * @memberof StudyFull
     */
    'banner_image_url'?: string;
    /**
     * 
     * @type {MeasurementIntegrationPlatform}
     * @memberof StudyFull
     */
    'integration_platform'?: MeasurementIntegrationPlatform;
    /**
     * Determines if the study is an example study, used to demonstrate product capabilities
     * @type {boolean}
     * @memberof StudyFull
     */
    'is_example'?: boolean;
    /**
     * Date and time of the object creation
     * @type {string}
     * @memberof StudyFull
     */
    'created_at': string;
    /**
     * ID of the user who created the object
     * @type {string}
     * @memberof StudyFull
     */
    'created_by': string;
    /**
     * Date and time of the latest update to the object
     * @type {string}
     * @memberof StudyFull
     */
    'updated_at'?: string;
    /**
     * ID of the user who last updated the object
     * @type {string}
     * @memberof StudyFull
     */
    'updated_by'?: string;
}


/**
 * The status of the data collection of the study, indicating whether stats are available and representative.  * `no_data` means that the study has been created but no data has been received. * `active_ramping_up` means that data has been received, but not enough to provide meaningful stats yet. * `active_fulfilled` means that the study has received a good amount of data, but more data can still be added. * `finished_complete` means that the study has finished and is no longer open to receive data. * `finished_expired` means that the study has finished but not enough data was collected to provide meaningful stats. 
 * @export
 * @enum {string}
 */

export const StudyIngestionStatus = {
    NoData: 'no_data',
    ActiveRampingUp: 'active_ramping_up',
    ActiveFulfilled: 'active_fulfilled',
    FinishedComplete: 'finished_complete',
    FinishedExpired: 'finished_expired'
} as const;

export type StudyIngestionStatus = typeof StudyIngestionStatus[keyof typeof StudyIngestionStatus];


/**
 * 
 * @export
 * @interface StudyItem
 */
export interface StudyItem {
    /**
     * Unique ID for the object
     * @type {string}
     * @memberof StudyItem
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof StudyItem
     */
    'name'?: string;
    /**
     * A set of labels that users can use to categorize their measurements. Can be used to indicate type of study, customer names or other traits. 
     * @type {Array<string>}
     * @memberof StudyItem
     */
    'labels'?: Array<string>;
    /**
     * The ID of the account that owns this study
     * @type {string}
     * @memberof StudyItem
     */
    'account_id'?: string;
    /**
     * The date for which the study and its data ingestion will start
     * @type {string}
     * @memberof StudyItem
     */
    'start_date'?: string;
    /**
     * 
     * @type {StudyLifecycleStage}
     * @memberof StudyItem
     */
    'life_cycle_stage'?: StudyLifecycleStage;
    /**
     * 
     * @type {StudyIngestionStatus}
     * @memberof StudyItem
     */
    'ingestion_status'?: StudyIngestionStatus;
    /**
     * 
     * @type {StudySummaryStats}
     * @memberof StudyItem
     */
    'summary_stats'?: StudySummaryStats;
    /**
     * 
     * @type {MeasurementClientItem}
     * @memberof StudyItem
     */
    'client'?: MeasurementClientItem;
}


/**
 * The life cycle stage of the study. 
 * @export
 * @enum {string}
 */

export const StudyLifecycleStage = {
    Pending: 'pending',
    Active: 'active',
    Paused: 'paused',
    Finished: 'finished'
} as const;

export type StudyLifecycleStage = typeof StudyLifecycleStage[keyof typeof StudyLifecycleStage];


/**
 * 
 * @export
 * @interface StudyLinks
 */
export interface StudyLinks {
    /**
     * Link to the country statistics for the study
     * @type {string}
     * @memberof StudyLinks
     */
    'stats_countries'?: string;
    /**
     * Link to the audience statistics for the study
     * @type {string}
     * @memberof StudyLinks
     */
    'stats_audiences'?: string;
    /**
     * Link to the timing statistics for the study
     * @type {string}
     * @memberof StudyLinks
     */
    'stats_timing'?: string;
    /**
     * Link to the frequency statistics for the study
     * @type {string}
     * @memberof StudyLinks
     */
    'stats_frequencies'?: string;
}
/**
 * 
 * @export
 * @interface StudyMeta
 */
export interface StudyMeta {
    /**
     * 
     * @type {StudyPermissions}
     * @memberof StudyMeta
     */
    'permissions'?: StudyPermissions;
}
/**
 * 
 * @export
 * @interface StudyMutation
 */
export interface StudyMutation {
    /**
     * 
     * @type {string}
     * @memberof StudyMutation
     */
    'name'?: string;
    /**
     * A set of labels that users can use to categorize their measurements. Can be used to indicate type of study, customer names or other traits. 
     * @type {Array<string>}
     * @memberof StudyMutation
     */
    'labels'?: Array<string>;
    /**
     * The ID of the account that owns this study
     * @type {string}
     * @memberof StudyMutation
     */
    'account_id'?: string;
    /**
     * The date for which the study and its data ingestion will start
     * @type {string}
     * @memberof StudyMutation
     */
    'start_date'?: string;
    /**
     * 
     * @type {StudyLifecycleStage}
     * @memberof StudyMutation
     */
    'life_cycle_stage'?: StudyLifecycleStage;
    /**
     * 
     * @type {StudyIngestionStatus}
     * @memberof StudyMutation
     */
    'ingestion_status'?: StudyIngestionStatus;
    /**
     * 
     * @type {StudySummaryStats}
     * @memberof StudyMutation
     */
    'summary_stats'?: StudySummaryStats;
    /**
     * 
     * @type {MeasurementClientItem}
     * @memberof StudyMutation
     */
    'client'?: MeasurementClientItem;
    /**
     * 
     * @type {MeasurementEventLinks}
     * @memberof StudyMutation
     */
    'event_links'?: MeasurementEventLinks;
    /**
     * The URL to a banner image for the study. Note that the banner image is used only for Digiseg study reporting and presentation, it does NOT represent any delivered banner ad creatives or similar. 
     * @type {string}
     * @memberof StudyMutation
     */
    'banner_image_url'?: string;
    /**
     * 
     * @type {MeasurementIntegrationPlatform}
     * @memberof StudyMutation
     */
    'integration_platform'?: MeasurementIntegrationPlatform;
    /**
     * Determines if the study is an example study, used to demonstrate product capabilities
     * @type {boolean}
     * @memberof StudyMutation
     */
    'is_example'?: boolean;
}


/**
 * Provides information about the current user\'s permissions of a study
 * @export
 * @interface StudyPermissions
 */
export interface StudyPermissions {
    /**
     * Can the current user GET (read) study information?
     * @type {boolean}
     * @memberof StudyPermissions
     */
    'get': boolean;
    /**
     * Can the current user PUT (update) study information?
     * @type {boolean}
     * @memberof StudyPermissions
     */
    'put': boolean;
    /**
     * Can the current user DELETE the study?
     * @type {boolean}
     * @memberof StudyPermissions
     */
    'delete': boolean;
}
/**
 * 
 * @export
 * @interface StudySummaryStats
 */
export interface StudySummaryStats {
    /**
     * 
     * @type {MeasurementsContainer}
     * @memberof StudySummaryStats
     */
    'private': MeasurementsContainer;
    /**
     * 
     * @type {MeasurementsContainer}
     * @memberof StudySummaryStats
     */
    'business': MeasurementsContainer;
    /**
     * 
     * @type {MeasurementsContainer}
     * @memberof StudySummaryStats
     */
    'not_resolved': MeasurementsContainer;
}
/**
 * 
 * @export
 * @interface StudyTimingStats
 */
export interface StudyTimingStats {
    /**
     * 
     * @type {HourOfDayStats}
     * @memberof StudyTimingStats
     */
    'hour_of_day'?: HourOfDayStats;
    /**
     * 
     * @type {DayOfWeekStats}
     * @memberof StudyTimingStats
     */
    'day_of_week'?: DayOfWeekStats;
    /**
     * 
     * @type {DayOfMonthStats}
     * @memberof StudyTimingStats
     */
    'day_of_month'?: DayOfMonthStats;
}
/**
 * Defines a subscription plan (a feature set at a given pricing configuration)
 * @export
 * @interface SubscriptionPlan
 */
export interface SubscriptionPlan {
    /**
     * The ID of the plan/price that the account is subscribed to
     * @type {string}
     * @memberof SubscriptionPlan
     */
    'id'?: string;
    /**
     * Is the plan/price a public price or custom?
     * @type {boolean}
     * @memberof SubscriptionPlan
     */
    'is_public'?: boolean;
    /**
     * The display name of the price/plan
     * @type {string}
     * @memberof SubscriptionPlan
     */
    'display_name'?: string;
    /**
     * An optional code, typically provided if the plan/price is public and advertised
     * @type {string}
     * @memberof SubscriptionPlan
     */
    'code'?: string;
    /**
     * 
     * @type {PlanFeatureSet}
     * @memberof SubscriptionPlan
     */
    'feature_set'?: PlanFeatureSet;
}
/**
 * 
 * @export
 * @interface TimestampedObject
 */
export interface TimestampedObject {
    /**
     * Date and time of the object creation
     * @type {string}
     * @memberof TimestampedObject
     */
    'created_at'?: string;
    /**
     * ID of the user who created the object
     * @type {string}
     * @memberof TimestampedObject
     */
    'created_by'?: string;
    /**
     * Date and time of the latest update to the object
     * @type {string}
     * @memberof TimestampedObject
     */
    'updated_at'?: string;
    /**
     * ID of the user who last updated the object
     * @type {string}
     * @memberof TimestampedObject
     */
    'updated_by'?: string;
}
/**
 * 
 * @export
 * @interface TimestampedObject1
 */
export interface TimestampedObject1 {
    /**
     * Date and time of the object creation
     * @type {string}
     * @memberof TimestampedObject1
     */
    'created_at': string;
    /**
     * ID of the user who created the object
     * @type {string}
     * @memberof TimestampedObject1
     */
    'created_by': string;
    /**
     * Date and time of the latest update to the object
     * @type {string}
     * @memberof TimestampedObject1
     */
    'updated_at'?: string;
    /**
     * ID of the user who last updated the object
     * @type {string}
     * @memberof TimestampedObject1
     */
    'updated_by'?: string;
}
/**
 * Describes a user\'s membership of an account
 * @export
 * @interface UserAccountMembership
 */
export interface UserAccountMembership {
    /**
     * The ID of the account
     * @type {string}
     * @memberof UserAccountMembership
     */
    'account_id': string;
    /**
     * The name of the account
     * @type {string}
     * @memberof UserAccountMembership
     */
    'account_name'?: string;
    /**
     * The roles that the user has within the account
     * @type {Array<UserAccountRole>}
     * @memberof UserAccountMembership
     */
    'roles': Array<UserAccountRole>;
}
/**
 * Determines the role of a user within an account. The permissions of each role are defined to fulfill the following use cases: * `user` is a basic role needed to make use of the platforms primary features. * `admin` is required to perform administrative functions on the account, such as adding members to it. Admin permissions does NOT include removing the account altogether or billing-related actions. * `owner` is required to make changes to account billing, or delete the account. 
 * @export
 * @enum {string}
 */

export const UserAccountRole = {
    Owner: 'owner',
    Admin: 'admin',
    User: 'user'
} as const;

export type UserAccountRole = typeof UserAccountRole[keyof typeof UserAccountRole];


/**
 * 
 * @export
 * @interface UserAux
 */
export interface UserAux {
    /**
     * 
     * @type {Array<UserAccountMembership>}
     * @memberof UserAux
     */
    'account_memberships'?: Array<UserAccountMembership>;
    /**
     * Determines if the user is a super admin of Digiseg API services
     * @type {boolean}
     * @memberof UserAux
     * @deprecated
     */
    'is_super_admin'?: boolean;
    /**
     * 
     * @type {Array<UserPlatformRole>}
     * @memberof UserAux
     */
    'platform_roles'?: Array<UserPlatformRole>;
}
/**
 * 
 * @export
 * @interface UserBase
 */
export interface UserBase {
    /**
     * The email of the user (used as username when authenticating with password)
     * @type {string}
     * @memberof UserBase
     */
    'email'?: string;
    /**
     * Human readable name of the user
     * @type {string}
     * @memberof UserBase
     */
    'name'?: string;
    /**
     * ID of the account that this user pertains to. If the user has multiple account memberships, this account ID will represent the primary account of the user. 
     * @type {string}
     * @memberof UserBase
     */
    'account_id'?: string;
    /**
     * The roles that the user has within the account
     * @type {Array<UserAccountRole>}
     * @memberof UserBase
     */
    'roles'?: Array<UserAccountRole>;
    /**
     * The URL to an avatar of the user
     * @type {string}
     * @memberof UserBase
     */
    'avatar_url'?: string;
    /**
     * The approximate last time that the user logged in
     * @type {string}
     * @memberof UserBase
     */
    'logged_in_at'?: string;
}
/**
 * 
 * @export
 * @interface UserCreation
 */
export interface UserCreation {
    /**
     * The email of the user (used as username when authenticating with password)
     * @type {string}
     * @memberof UserCreation
     */
    'email'?: string;
    /**
     * Human readable name of the user
     * @type {string}
     * @memberof UserCreation
     */
    'name'?: string;
    /**
     * ID of the account that this user pertains to. If the user has multiple account memberships, this account ID will represent the primary account of the user. 
     * @type {string}
     * @memberof UserCreation
     */
    'account_id'?: string;
    /**
     * The roles that the user has within the account
     * @type {Array<UserAccountRole>}
     * @memberof UserCreation
     */
    'roles'?: Array<UserAccountRole>;
    /**
     * The URL to an avatar of the user
     * @type {string}
     * @memberof UserCreation
     */
    'avatar_url'?: string;
    /**
     * The approximate last time that the user logged in
     * @type {string}
     * @memberof UserCreation
     */
    'logged_in_at'?: string;
    /**
     * 
     * @type {Array<UserAccountMembership>}
     * @memberof UserCreation
     */
    'account_memberships'?: Array<UserAccountMembership>;
    /**
     * Determines if the user is a super admin of Digiseg API services
     * @type {boolean}
     * @memberof UserCreation
     * @deprecated
     */
    'is_super_admin'?: boolean;
    /**
     * 
     * @type {Array<UserPlatformRole>}
     * @memberof UserCreation
     */
    'platform_roles'?: Array<UserPlatformRole>;
    /**
     * Password of the user
     * @type {string}
     * @memberof UserCreation
     */
    'password'?: string;
    /**
     * Whether or not to notify the user that they have been registered
     * @type {boolean}
     * @memberof UserCreation
     */
    'notify_user'?: boolean;
}
/**
 * 
 * @export
 * @interface UserCreationNotification
 */
export interface UserCreationNotification {
    /**
     * Whether or not to notify the user that they have been registered
     * @type {boolean}
     * @memberof UserCreationNotification
     */
    'notify_user'?: boolean;
}
/**
 * 
 * @export
 * @interface UserCredentials
 */
export interface UserCredentials {
    /**
     * Password of the user
     * @type {string}
     * @memberof UserCredentials
     */
    'password'?: string;
}
/**
 * 
 * @export
 * @interface UserFull
 */
export interface UserFull {
    /**
     * Unique ID for the object
     * @type {string}
     * @memberof UserFull
     */
    'id'?: string;
    /**
     * The email of the user (used as username when authenticating with password)
     * @type {string}
     * @memberof UserFull
     */
    'email'?: string;
    /**
     * Human readable name of the user
     * @type {string}
     * @memberof UserFull
     */
    'name'?: string;
    /**
     * ID of the account that this user pertains to. If the user has multiple account memberships, this account ID will represent the primary account of the user. 
     * @type {string}
     * @memberof UserFull
     */
    'account_id'?: string;
    /**
     * The roles that the user has within the account
     * @type {Array<UserAccountRole>}
     * @memberof UserFull
     */
    'roles'?: Array<UserAccountRole>;
    /**
     * The URL to an avatar of the user
     * @type {string}
     * @memberof UserFull
     */
    'avatar_url'?: string;
    /**
     * The approximate last time that the user logged in
     * @type {string}
     * @memberof UserFull
     */
    'logged_in_at'?: string;
    /**
     * 
     * @type {Array<UserAccountMembership>}
     * @memberof UserFull
     */
    'account_memberships'?: Array<UserAccountMembership>;
    /**
     * Determines if the user is a super admin of Digiseg API services
     * @type {boolean}
     * @memberof UserFull
     * @deprecated
     */
    'is_super_admin'?: boolean;
    /**
     * 
     * @type {Array<UserPlatformRole>}
     * @memberof UserFull
     */
    'platform_roles'?: Array<UserPlatformRole>;
    /**
     * Date and time of the object creation
     * @type {string}
     * @memberof UserFull
     */
    'created_at'?: string;
    /**
     * ID of the user who created the object
     * @type {string}
     * @memberof UserFull
     */
    'created_by'?: string;
    /**
     * Date and time of the latest update to the object
     * @type {string}
     * @memberof UserFull
     */
    'updated_at'?: string;
    /**
     * ID of the user who last updated the object
     * @type {string}
     * @memberof UserFull
     */
    'updated_by'?: string;
}
/**
 * 
 * @export
 * @interface UserItem
 */
export interface UserItem {
    /**
     * Unique ID for the object
     * @type {string}
     * @memberof UserItem
     */
    'id'?: string;
    /**
     * The email of the user (used as username when authenticating with password)
     * @type {string}
     * @memberof UserItem
     */
    'email'?: string;
    /**
     * Human readable name of the user
     * @type {string}
     * @memberof UserItem
     */
    'name'?: string;
    /**
     * ID of the account that this user pertains to. If the user has multiple account memberships, this account ID will represent the primary account of the user. 
     * @type {string}
     * @memberof UserItem
     */
    'account_id'?: string;
    /**
     * The roles that the user has within the account
     * @type {Array<UserAccountRole>}
     * @memberof UserItem
     */
    'roles'?: Array<UserAccountRole>;
    /**
     * The URL to an avatar of the user
     * @type {string}
     * @memberof UserItem
     */
    'avatar_url'?: string;
    /**
     * The approximate last time that the user logged in
     * @type {string}
     * @memberof UserItem
     */
    'logged_in_at'?: string;
}
/**
 * 
 * @export
 * @interface UserLinks
 */
export interface UserLinks {
    /**
     * Link for getting to the user\'s account
     * @type {string}
     * @memberof UserLinks
     */
    'account'?: string;
    /**
     * Link for getting to the user\'s api keys
     * @type {string}
     * @memberof UserLinks
     */
    'apikeys'?: string;
}
/**
 * 
 * @export
 * @interface UserMutation
 */
export interface UserMutation {
    /**
     * The email of the user (used as username when authenticating with password)
     * @type {string}
     * @memberof UserMutation
     */
    'email'?: string;
    /**
     * Human readable name of the user
     * @type {string}
     * @memberof UserMutation
     */
    'name'?: string;
    /**
     * ID of the account that this user pertains to. If the user has multiple account memberships, this account ID will represent the primary account of the user. 
     * @type {string}
     * @memberof UserMutation
     */
    'account_id'?: string;
    /**
     * The roles that the user has within the account
     * @type {Array<UserAccountRole>}
     * @memberof UserMutation
     */
    'roles'?: Array<UserAccountRole>;
    /**
     * The URL to an avatar of the user
     * @type {string}
     * @memberof UserMutation
     */
    'avatar_url'?: string;
    /**
     * The approximate last time that the user logged in
     * @type {string}
     * @memberof UserMutation
     */
    'logged_in_at'?: string;
    /**
     * 
     * @type {Array<UserAccountMembership>}
     * @memberof UserMutation
     */
    'account_memberships'?: Array<UserAccountMembership>;
    /**
     * Determines if the user is a super admin of Digiseg API services
     * @type {boolean}
     * @memberof UserMutation
     * @deprecated
     */
    'is_super_admin'?: boolean;
    /**
     * 
     * @type {Array<UserPlatformRole>}
     * @memberof UserMutation
     */
    'platform_roles'?: Array<UserPlatformRole>;
    /**
     * Password of the user
     * @type {string}
     * @memberof UserMutation
     */
    'password'?: string;
}
/**
 * Defines the role of the user in the Digiseg platform. Most users will not have any platform roles, since this is preserved for account-agnostic operational privileges. 
 * @export
 * @enum {string}
 */

export const UserPlatformRole = {
    SuperAdmin: 'super_admin',
    DevOps: 'dev_ops',
    CustomerOps: 'customer_ops'
} as const;

export type UserPlatformRole = typeof UserPlatformRole[keyof typeof UserPlatformRole];


/**
 * 
 * @export
 * @enum {string}
 */

export const UserSortOption = {
    CreatedAt: 'created_at',
    CreatedAt2: '-created_at',
    Name: 'name',
    Name2: '-name',
    LoggedInAt: 'logged_in_at',
    LoggedInAt2: '-logged_in_at'
} as const;

export type UserSortOption = typeof UserSortOption[keyof typeof UserSortOption];



/**
 * AccountsApi - axios parameter creator
 * @export
 */
export const AccountsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a user within the referenced account. 
         * @summary Create user
         * @param {string} accountId 
         * @param {UserCreation} userCreation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserInAccount: async (accountId: string, userCreation: UserCreation, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('createUserInAccount', 'accountId', accountId)
            // verify required parameter 'userCreation' is not null or undefined
            assertParamExists('createUserInAccount', 'userCreation', userCreation)
            const localVarPath = `/accounts/{account_id}/users`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication apiKeyHeaderAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication apiKeyQueryParamAuth required
            await setApiKeyToObject(localVarQueryParameter, "api_key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userCreation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the logo for an account 
         * @summary Delete account logo
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccountLogo: async (accountId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('deleteAccountLogo', 'accountId', accountId)
            const localVarPath = `/accounts/{account_id}/assets/logo`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication apiKeyHeaderAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication apiKeyQueryParamAuth required
            await setApiKeyToObject(localVarQueryParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get account
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountById: async (accountId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getAccountById', 'accountId', accountId)
            const localVarPath = `/accounts/{account_id}`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication apiKeyHeaderAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication apiKeyQueryParamAuth required
            await setApiKeyToObject(localVarQueryParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the account logo, if the image is hosted on the Digiseg platform. Refer to the account\'s `logo_url` to get a non-authenticated and shareable URL for the logo. 
         * @summary Get account logo
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountLogo: async (accountId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getAccountLogo', 'accountId', accountId)
            const localVarPath = `/accounts/{account_id}/assets/logo`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication apiKeyHeaderAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication apiKeyQueryParamAuth required
            await setApiKeyToObject(localVarQueryParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a specific subscription for an account
         * @summary Get account subscription
         * @param {string} accountId 
         * @param {string} subscriptionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountSubscriptionById: async (accountId: string, subscriptionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getAccountSubscriptionById', 'accountId', accountId)
            // verify required parameter 'subscriptionId' is not null or undefined
            assertParamExists('getAccountSubscriptionById', 'subscriptionId', subscriptionId)
            const localVarPath = `/accounts/{account_id}/subscriptions/{subscription_id}`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"subscription_id"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication apiKeyHeaderAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication apiKeyQueryParamAuth required
            await setApiKeyToObject(localVarQueryParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a summary of subscriptions for an account
         * @summary Get account subscriptions summary
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountSubscriptions: async (accountId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getAccountSubscriptions', 'accountId', accountId)
            const localVarPath = `/accounts/{account_id}/subscriptions`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication apiKeyHeaderAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication apiKeyQueryParamAuth required
            await setApiKeyToObject(localVarQueryParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List API keys for account
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApiKeysByAccountId: async (accountId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('listApiKeysByAccountId', 'accountId', accountId)
            const localVarPath = `/accounts/{account_id}/apikeys`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication apiKeyHeaderAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication apiKeyQueryParamAuth required
            await setApiKeyToObject(localVarQueryParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List users for account
         * @param {string} accountId 
         * @param {UserPlatformRole} [filterPlatformRoles] Filter based on platform roles, e.g. super_admin
         * @param {string} [filterNameContains] Optional parameter used to search for users where the name contains a substring (case insensitive)
         * @param {UserSortOption} [sort] Defines the field to sort the result items by. Ascending order is applied by default, but the minus character can be used to indicate descending order instead. 
         * @param {number} [pageSize] The desired page size
         * @param {string} [pageAfter] Optional pagination parameter, indicating the previous cursor value to paginate beyond. The value to provide here is opaque, but can be found in previous requests in the &#x60;meta.page.last_cursor&#x60; field. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsersByAccountId: async (accountId: string, filterPlatformRoles?: UserPlatformRole, filterNameContains?: string, sort?: UserSortOption, pageSize?: number, pageAfter?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('listUsersByAccountId', 'accountId', accountId)
            const localVarPath = `/accounts/{account_id}/users`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication apiKeyHeaderAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication apiKeyQueryParamAuth required
            await setApiKeyToObject(localVarQueryParameter, "api_key", configuration)

            if (filterPlatformRoles !== undefined) {
                localVarQueryParameter['filter[platform_roles]'] = filterPlatformRoles;
            }

            if (filterNameContains !== undefined) {
                localVarQueryParameter['filter[name][contains]'] = filterNameContains;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page[size]'] = pageSize;
            }

            if (pageAfter !== undefined) {
                localVarQueryParameter['page[after]'] = pageAfter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update account
         * @param {string} accountId 
         * @param {AccountMutation} accountMutation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccountById: async (accountId: string, accountMutation: AccountMutation, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('updateAccountById', 'accountId', accountId)
            // verify required parameter 'accountMutation' is not null or undefined
            assertParamExists('updateAccountById', 'accountMutation', accountMutation)
            const localVarPath = `/accounts/{account_id}`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication apiKeyHeaderAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication apiKeyQueryParamAuth required
            await setApiKeyToObject(localVarQueryParameter, "api_key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountMutation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload a logo for an account 
         * @summary Upload account logo
         * @param {string} accountId 
         * @param {File} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadAccountLogo: async (accountId: string, body: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('uploadAccountLogo', 'accountId', accountId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('uploadAccountLogo', 'body', body)
            const localVarPath = `/accounts/{account_id}/assets/logo`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication apiKeyHeaderAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication apiKeyQueryParamAuth required
            await setApiKeyToObject(localVarQueryParameter, "api_key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'image/gif';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountsApi - functional programming interface
 * @export
 */
export const AccountsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a user within the referenced account. 
         * @summary Create user
         * @param {string} accountId 
         * @param {UserCreation} userCreation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserInAccount(accountId: string, userCreation: UserCreation, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateUserInAccount201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUserInAccount(accountId, userCreation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsApi.createUserInAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes the logo for an account 
         * @summary Delete account logo
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAccountLogo(accountId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAccountLogo(accountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsApi.deleteAccountLogo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get account
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountById(accountId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAccountById200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountById(accountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsApi.getAccountById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Gets the account logo, if the image is hosted on the Digiseg platform. Refer to the account\'s `logo_url` to get a non-authenticated and shareable URL for the logo. 
         * @summary Get account logo
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountLogo(accountId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountLogo(accountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsApi.getAccountLogo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Gets a specific subscription for an account
         * @summary Get account subscription
         * @param {string} accountId 
         * @param {string} subscriptionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountSubscriptionById(accountId: string, subscriptionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAccountSubscriptionById200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountSubscriptionById(accountId, subscriptionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsApi.getAccountSubscriptionById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a summary of subscriptions for an account
         * @summary Get account subscriptions summary
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountSubscriptions(accountId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAccountSubscriptions200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountSubscriptions(accountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsApi.getAccountSubscriptions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List API keys for account
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listApiKeysByAccountId(accountId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListApiKeysByAccountId200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listApiKeysByAccountId(accountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsApi.listApiKeysByAccountId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List users for account
         * @param {string} accountId 
         * @param {UserPlatformRole} [filterPlatformRoles] Filter based on platform roles, e.g. super_admin
         * @param {string} [filterNameContains] Optional parameter used to search for users where the name contains a substring (case insensitive)
         * @param {UserSortOption} [sort] Defines the field to sort the result items by. Ascending order is applied by default, but the minus character can be used to indicate descending order instead. 
         * @param {number} [pageSize] The desired page size
         * @param {string} [pageAfter] Optional pagination parameter, indicating the previous cursor value to paginate beyond. The value to provide here is opaque, but can be found in previous requests in the &#x60;meta.page.last_cursor&#x60; field. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUsersByAccountId(accountId: string, filterPlatformRoles?: UserPlatformRole, filterNameContains?: string, sort?: UserSortOption, pageSize?: number, pageAfter?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListUsersByAccountId200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUsersByAccountId(accountId, filterPlatformRoles, filterNameContains, sort, pageSize, pageAfter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsApi.listUsersByAccountId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update account
         * @param {string} accountId 
         * @param {AccountMutation} accountMutation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAccountById(accountId: string, accountMutation: AccountMutation, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAccountById200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAccountById(accountId, accountMutation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsApi.updateAccountById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Upload a logo for an account 
         * @summary Upload account logo
         * @param {string} accountId 
         * @param {File} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadAccountLogo(accountId: string, body: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadAccountLogo(accountId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsApi.uploadAccountLogo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AccountsApi - factory interface
 * @export
 */
export const AccountsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountsApiFp(configuration)
    return {
        /**
         * Create a user within the referenced account. 
         * @summary Create user
         * @param {string} accountId 
         * @param {UserCreation} userCreation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserInAccount(accountId: string, userCreation: UserCreation, options?: any): AxiosPromise<CreateUserInAccount201Response> {
            return localVarFp.createUserInAccount(accountId, userCreation, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the logo for an account 
         * @summary Delete account logo
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccountLogo(accountId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteAccountLogo(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get account
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountById(accountId: string, options?: any): AxiosPromise<GetAccountById200Response> {
            return localVarFp.getAccountById(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the account logo, if the image is hosted on the Digiseg platform. Refer to the account\'s `logo_url` to get a non-authenticated and shareable URL for the logo. 
         * @summary Get account logo
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountLogo(accountId: string, options?: any): AxiosPromise<void> {
            return localVarFp.getAccountLogo(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a specific subscription for an account
         * @summary Get account subscription
         * @param {string} accountId 
         * @param {string} subscriptionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountSubscriptionById(accountId: string, subscriptionId: string, options?: any): AxiosPromise<GetAccountSubscriptionById200Response> {
            return localVarFp.getAccountSubscriptionById(accountId, subscriptionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a summary of subscriptions for an account
         * @summary Get account subscriptions summary
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountSubscriptions(accountId: string, options?: any): AxiosPromise<GetAccountSubscriptions200Response> {
            return localVarFp.getAccountSubscriptions(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List API keys for account
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApiKeysByAccountId(accountId: string, options?: any): AxiosPromise<ListApiKeysByAccountId200Response> {
            return localVarFp.listApiKeysByAccountId(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List users for account
         * @param {string} accountId 
         * @param {UserPlatformRole} [filterPlatformRoles] Filter based on platform roles, e.g. super_admin
         * @param {string} [filterNameContains] Optional parameter used to search for users where the name contains a substring (case insensitive)
         * @param {UserSortOption} [sort] Defines the field to sort the result items by. Ascending order is applied by default, but the minus character can be used to indicate descending order instead. 
         * @param {number} [pageSize] The desired page size
         * @param {string} [pageAfter] Optional pagination parameter, indicating the previous cursor value to paginate beyond. The value to provide here is opaque, but can be found in previous requests in the &#x60;meta.page.last_cursor&#x60; field. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsersByAccountId(accountId: string, filterPlatformRoles?: UserPlatformRole, filterNameContains?: string, sort?: UserSortOption, pageSize?: number, pageAfter?: string, options?: any): AxiosPromise<ListUsersByAccountId200Response> {
            return localVarFp.listUsersByAccountId(accountId, filterPlatformRoles, filterNameContains, sort, pageSize, pageAfter, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update account
         * @param {string} accountId 
         * @param {AccountMutation} accountMutation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccountById(accountId: string, accountMutation: AccountMutation, options?: any): AxiosPromise<GetAccountById200Response> {
            return localVarFp.updateAccountById(accountId, accountMutation, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload a logo for an account 
         * @summary Upload account logo
         * @param {string} accountId 
         * @param {File} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadAccountLogo(accountId: string, body: File, options?: any): AxiosPromise<void> {
            return localVarFp.uploadAccountLogo(accountId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountsApi - object-oriented interface
 * @export
 * @class AccountsApi
 * @extends {BaseAPI}
 */
export class AccountsApi extends BaseAPI {
    /**
     * Create a user within the referenced account. 
     * @summary Create user
     * @param {string} accountId 
     * @param {UserCreation} userCreation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public createUserInAccount(accountId: string, userCreation: UserCreation, options?: RawAxiosRequestConfig) {
        return AccountsApiFp(this.configuration).createUserInAccount(accountId, userCreation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the logo for an account 
     * @summary Delete account logo
     * @param {string} accountId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public deleteAccountLogo(accountId: string, options?: RawAxiosRequestConfig) {
        return AccountsApiFp(this.configuration).deleteAccountLogo(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get account
     * @param {string} accountId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getAccountById(accountId: string, options?: RawAxiosRequestConfig) {
        return AccountsApiFp(this.configuration).getAccountById(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets the account logo, if the image is hosted on the Digiseg platform. Refer to the account\'s `logo_url` to get a non-authenticated and shareable URL for the logo. 
     * @summary Get account logo
     * @param {string} accountId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getAccountLogo(accountId: string, options?: RawAxiosRequestConfig) {
        return AccountsApiFp(this.configuration).getAccountLogo(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a specific subscription for an account
     * @summary Get account subscription
     * @param {string} accountId 
     * @param {string} subscriptionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getAccountSubscriptionById(accountId: string, subscriptionId: string, options?: RawAxiosRequestConfig) {
        return AccountsApiFp(this.configuration).getAccountSubscriptionById(accountId, subscriptionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a summary of subscriptions for an account
     * @summary Get account subscriptions summary
     * @param {string} accountId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getAccountSubscriptions(accountId: string, options?: RawAxiosRequestConfig) {
        return AccountsApiFp(this.configuration).getAccountSubscriptions(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List API keys for account
     * @param {string} accountId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public listApiKeysByAccountId(accountId: string, options?: RawAxiosRequestConfig) {
        return AccountsApiFp(this.configuration).listApiKeysByAccountId(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List users for account
     * @param {string} accountId 
     * @param {UserPlatformRole} [filterPlatformRoles] Filter based on platform roles, e.g. super_admin
     * @param {string} [filterNameContains] Optional parameter used to search for users where the name contains a substring (case insensitive)
     * @param {UserSortOption} [sort] Defines the field to sort the result items by. Ascending order is applied by default, but the minus character can be used to indicate descending order instead. 
     * @param {number} [pageSize] The desired page size
     * @param {string} [pageAfter] Optional pagination parameter, indicating the previous cursor value to paginate beyond. The value to provide here is opaque, but can be found in previous requests in the &#x60;meta.page.last_cursor&#x60; field. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public listUsersByAccountId(accountId: string, filterPlatformRoles?: UserPlatformRole, filterNameContains?: string, sort?: UserSortOption, pageSize?: number, pageAfter?: string, options?: RawAxiosRequestConfig) {
        return AccountsApiFp(this.configuration).listUsersByAccountId(accountId, filterPlatformRoles, filterNameContains, sort, pageSize, pageAfter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update account
     * @param {string} accountId 
     * @param {AccountMutation} accountMutation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public updateAccountById(accountId: string, accountMutation: AccountMutation, options?: RawAxiosRequestConfig) {
        return AccountsApiFp(this.configuration).updateAccountById(accountId, accountMutation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload a logo for an account 
     * @summary Upload account logo
     * @param {string} accountId 
     * @param {File} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public uploadAccountLogo(accountId: string, body: File, options?: RawAxiosRequestConfig) {
        return AccountsApiFp(this.configuration).uploadAccountLogo(accountId, body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AudiencesApi - axios parameter creator
 * @export
 */
export const AudiencesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get audiences of the API client
         * @param {string} [include] Optional parameter used to specify which audience information to be returned. The value is comprised of comma-separated values, each indicating a set of audiences:    * &#x60;core&#x60; represents the core audiences that are directly linked to household characteristics   * &#x60;composite&#x60; represents the composite audiences, used to model likely behaviours or buying     needs associated with the household characteristics.   * &#x60;name&#x60; and &#x60;category&#x60; refer to the fields of the same names in the returned Audience     objects. There is a slight performance gain in leaving these out when they are not needed. 
         * @param {string} [type] Optional parameter to set to &#x60;jsonp&#x60; if a JSONP response format is needed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resolveAudiencesOfClient: async (include?: string, type?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/audiences`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication apiKeyHeaderAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication apiKeyQueryParamAuth required
            await setApiKeyToObject(localVarQueryParameter, "api_key", configuration)

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get audiences for multiple IP addresses
         * @param {ResolveAudiencesOfMultipleRequest} resolveAudiencesOfMultipleRequest 
         * @param {string} [include] Optional parameter used to specify which audience information to be returned. The value is comprised of comma-separated values, each indicating a set of audiences:    * &#x60;core&#x60; represents the core audiences that are directly linked to household characteristics   * &#x60;composite&#x60; represents the composite audiences, used to model likely behaviours or buying     needs associated with the household characteristics.   * &#x60;name&#x60; and &#x60;category&#x60; refer to the fields of the same names in the returned Audience     objects. There is a slight performance gain in leaving these out when they are not needed. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resolveAudiencesOfMultiple: async (resolveAudiencesOfMultipleRequest: ResolveAudiencesOfMultipleRequest, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resolveAudiencesOfMultipleRequest' is not null or undefined
            assertParamExists('resolveAudiencesOfMultiple', 'resolveAudiencesOfMultipleRequest', resolveAudiencesOfMultipleRequest)
            const localVarPath = `/audiences`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication apiKeyHeaderAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication apiKeyQueryParamAuth required
            await setApiKeyToObject(localVarQueryParameter, "api_key", configuration)

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resolveAudiencesOfMultipleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get audiences for a given IP address
         * @param {string} userIp The IP address to look up.
         * @param {string} [include] Optional parameter used to specify which audience information to be returned. The value is comprised of comma-separated values, each indicating a set of audiences:    * &#x60;core&#x60; represents the core audiences that are directly linked to household characteristics   * &#x60;composite&#x60; represents the composite audiences, used to model likely behaviours or buying     needs associated with the household characteristics.   * &#x60;name&#x60; and &#x60;category&#x60; refer to the fields of the same names in the returned Audience     objects. There is a slight performance gain in leaving these out when they are not needed. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resolveAudiencesOfSingle: async (userIp: string, include?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userIp' is not null or undefined
            assertParamExists('resolveAudiencesOfSingle', 'userIp', userIp)
            const localVarPath = `/audiences/{user_ip}`
                .replace(`{${"user_ip"}}`, encodeURIComponent(String(userIp)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication apiKeyHeaderAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication apiKeyQueryParamAuth required
            await setApiKeyToObject(localVarQueryParameter, "api_key", configuration)

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AudiencesApi - functional programming interface
 * @export
 */
export const AudiencesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AudiencesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get audiences of the API client
         * @param {string} [include] Optional parameter used to specify which audience information to be returned. The value is comprised of comma-separated values, each indicating a set of audiences:    * &#x60;core&#x60; represents the core audiences that are directly linked to household characteristics   * &#x60;composite&#x60; represents the composite audiences, used to model likely behaviours or buying     needs associated with the household characteristics.   * &#x60;name&#x60; and &#x60;category&#x60; refer to the fields of the same names in the returned Audience     objects. There is a slight performance gain in leaving these out when they are not needed. 
         * @param {string} [type] Optional parameter to set to &#x60;jsonp&#x60; if a JSONP response format is needed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resolveAudiencesOfClient(include?: string, type?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AudienceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resolveAudiencesOfClient(include, type, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AudiencesApi.resolveAudiencesOfClient']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get audiences for multiple IP addresses
         * @param {ResolveAudiencesOfMultipleRequest} resolveAudiencesOfMultipleRequest 
         * @param {string} [include] Optional parameter used to specify which audience information to be returned. The value is comprised of comma-separated values, each indicating a set of audiences:    * &#x60;core&#x60; represents the core audiences that are directly linked to household characteristics   * &#x60;composite&#x60; represents the composite audiences, used to model likely behaviours or buying     needs associated with the household characteristics.   * &#x60;name&#x60; and &#x60;category&#x60; refer to the fields of the same names in the returned Audience     objects. There is a slight performance gain in leaving these out when they are not needed. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resolveAudiencesOfMultiple(resolveAudiencesOfMultipleRequest: ResolveAudiencesOfMultipleRequest, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResolveAudiencesOfMultipleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resolveAudiencesOfMultiple(resolveAudiencesOfMultipleRequest, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AudiencesApi.resolveAudiencesOfMultiple']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get audiences for a given IP address
         * @param {string} userIp The IP address to look up.
         * @param {string} [include] Optional parameter used to specify which audience information to be returned. The value is comprised of comma-separated values, each indicating a set of audiences:    * &#x60;core&#x60; represents the core audiences that are directly linked to household characteristics   * &#x60;composite&#x60; represents the composite audiences, used to model likely behaviours or buying     needs associated with the household characteristics.   * &#x60;name&#x60; and &#x60;category&#x60; refer to the fields of the same names in the returned Audience     objects. There is a slight performance gain in leaving these out when they are not needed. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resolveAudiencesOfSingle(userIp: string, include?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AudienceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resolveAudiencesOfSingle(userIp, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AudiencesApi.resolveAudiencesOfSingle']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AudiencesApi - factory interface
 * @export
 */
export const AudiencesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AudiencesApiFp(configuration)
    return {
        /**
         * 
         * @summary Get audiences of the API client
         * @param {string} [include] Optional parameter used to specify which audience information to be returned. The value is comprised of comma-separated values, each indicating a set of audiences:    * &#x60;core&#x60; represents the core audiences that are directly linked to household characteristics   * &#x60;composite&#x60; represents the composite audiences, used to model likely behaviours or buying     needs associated with the household characteristics.   * &#x60;name&#x60; and &#x60;category&#x60; refer to the fields of the same names in the returned Audience     objects. There is a slight performance gain in leaving these out when they are not needed. 
         * @param {string} [type] Optional parameter to set to &#x60;jsonp&#x60; if a JSONP response format is needed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resolveAudiencesOfClient(include?: string, type?: string, options?: any): AxiosPromise<AudienceResponse> {
            return localVarFp.resolveAudiencesOfClient(include, type, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get audiences for multiple IP addresses
         * @param {ResolveAudiencesOfMultipleRequest} resolveAudiencesOfMultipleRequest 
         * @param {string} [include] Optional parameter used to specify which audience information to be returned. The value is comprised of comma-separated values, each indicating a set of audiences:    * &#x60;core&#x60; represents the core audiences that are directly linked to household characteristics   * &#x60;composite&#x60; represents the composite audiences, used to model likely behaviours or buying     needs associated with the household characteristics.   * &#x60;name&#x60; and &#x60;category&#x60; refer to the fields of the same names in the returned Audience     objects. There is a slight performance gain in leaving these out when they are not needed. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resolveAudiencesOfMultiple(resolveAudiencesOfMultipleRequest: ResolveAudiencesOfMultipleRequest, include?: string, options?: any): AxiosPromise<ResolveAudiencesOfMultipleResponse> {
            return localVarFp.resolveAudiencesOfMultiple(resolveAudiencesOfMultipleRequest, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get audiences for a given IP address
         * @param {string} userIp The IP address to look up.
         * @param {string} [include] Optional parameter used to specify which audience information to be returned. The value is comprised of comma-separated values, each indicating a set of audiences:    * &#x60;core&#x60; represents the core audiences that are directly linked to household characteristics   * &#x60;composite&#x60; represents the composite audiences, used to model likely behaviours or buying     needs associated with the household characteristics.   * &#x60;name&#x60; and &#x60;category&#x60; refer to the fields of the same names in the returned Audience     objects. There is a slight performance gain in leaving these out when they are not needed. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resolveAudiencesOfSingle(userIp: string, include?: string, options?: any): AxiosPromise<AudienceResponse> {
            return localVarFp.resolveAudiencesOfSingle(userIp, include, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AudiencesApi - object-oriented interface
 * @export
 * @class AudiencesApi
 * @extends {BaseAPI}
 */
export class AudiencesApi extends BaseAPI {
    /**
     * 
     * @summary Get audiences of the API client
     * @param {string} [include] Optional parameter used to specify which audience information to be returned. The value is comprised of comma-separated values, each indicating a set of audiences:    * &#x60;core&#x60; represents the core audiences that are directly linked to household characteristics   * &#x60;composite&#x60; represents the composite audiences, used to model likely behaviours or buying     needs associated with the household characteristics.   * &#x60;name&#x60; and &#x60;category&#x60; refer to the fields of the same names in the returned Audience     objects. There is a slight performance gain in leaving these out when they are not needed. 
     * @param {string} [type] Optional parameter to set to &#x60;jsonp&#x60; if a JSONP response format is needed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AudiencesApi
     */
    public resolveAudiencesOfClient(include?: string, type?: string, options?: RawAxiosRequestConfig) {
        return AudiencesApiFp(this.configuration).resolveAudiencesOfClient(include, type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get audiences for multiple IP addresses
     * @param {ResolveAudiencesOfMultipleRequest} resolveAudiencesOfMultipleRequest 
     * @param {string} [include] Optional parameter used to specify which audience information to be returned. The value is comprised of comma-separated values, each indicating a set of audiences:    * &#x60;core&#x60; represents the core audiences that are directly linked to household characteristics   * &#x60;composite&#x60; represents the composite audiences, used to model likely behaviours or buying     needs associated with the household characteristics.   * &#x60;name&#x60; and &#x60;category&#x60; refer to the fields of the same names in the returned Audience     objects. There is a slight performance gain in leaving these out when they are not needed. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AudiencesApi
     */
    public resolveAudiencesOfMultiple(resolveAudiencesOfMultipleRequest: ResolveAudiencesOfMultipleRequest, include?: string, options?: RawAxiosRequestConfig) {
        return AudiencesApiFp(this.configuration).resolveAudiencesOfMultiple(resolveAudiencesOfMultipleRequest, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get audiences for a given IP address
     * @param {string} userIp The IP address to look up.
     * @param {string} [include] Optional parameter used to specify which audience information to be returned. The value is comprised of comma-separated values, each indicating a set of audiences:    * &#x60;core&#x60; represents the core audiences that are directly linked to household characteristics   * &#x60;composite&#x60; represents the composite audiences, used to model likely behaviours or buying     needs associated with the household characteristics.   * &#x60;name&#x60; and &#x60;category&#x60; refer to the fields of the same names in the returned Audience     objects. There is a slight performance gain in leaving these out when they are not needed. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AudiencesApi
     */
    public resolveAudiencesOfSingle(userIp: string, include?: string, options?: RawAxiosRequestConfig) {
        return AudiencesApiFp(this.configuration).resolveAudiencesOfSingle(userIp, include, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Authenticate and create access token
         * @param {AuthTokenRequest} authTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccessToken: async (authTokenRequest: AuthTokenRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authTokenRequest' is not null or undefined
            assertParamExists('createAccessToken', 'authTokenRequest', authTokenRequest)
            const localVarPath = `/auth/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create API key for the given user. When an API key is created, the `token` value will be exposed in the response. This token can be passed as the `X-API-KEY` header value for future requests. It is not obtainable in other API requests (ie. the client must decide how to keep the API key token in e.g. a vault or similar). 
         * @summary Create API key
         * @param {string} userId 
         * @param {ApiKeyCreation} apiKeyCreation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApiKey: async (userId: string, apiKeyCreation: ApiKeyCreation, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('createApiKey', 'userId', userId)
            // verify required parameter 'apiKeyCreation' is not null or undefined
            assertParamExists('createApiKey', 'apiKeyCreation', apiKeyCreation)
            const localVarPath = `/users/{user_id}/apikeys`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication apiKeyHeaderAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication apiKeyQueryParamAuth required
            await setApiKeyToObject(localVarQueryParameter, "api_key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiKeyCreation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete API key
         * @param {string} userId 
         * @param {string} keyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApiKeyById: async (userId: string, keyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteApiKeyById', 'userId', userId)
            // verify required parameter 'keyId' is not null or undefined
            assertParamExists('deleteApiKeyById', 'keyId', keyId)
            const localVarPath = `/users/{user_id}/apikeys/{key_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"key_id"}}`, encodeURIComponent(String(keyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication apiKeyHeaderAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication apiKeyQueryParamAuth required
            await setApiKeyToObject(localVarQueryParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get API key
         * @param {string} userId 
         * @param {string} keyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiKeyById: async (userId: string, keyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getApiKeyById', 'userId', userId)
            // verify required parameter 'keyId' is not null or undefined
            assertParamExists('getApiKeyById', 'keyId', keyId)
            const localVarPath = `/users/{user_id}/apikeys/{key_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"key_id"}}`, encodeURIComponent(String(keyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication apiKeyHeaderAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication apiKeyQueryParamAuth required
            await setApiKeyToObject(localVarQueryParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List API keys for account
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApiKeysByAccountId: async (accountId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('listApiKeysByAccountId', 'accountId', accountId)
            const localVarPath = `/accounts/{account_id}/apikeys`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication apiKeyHeaderAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication apiKeyQueryParamAuth required
            await setApiKeyToObject(localVarQueryParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List API keys for user
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApiKeysByUserId: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('listApiKeysByUserId', 'userId', userId)
            const localVarPath = `/users/{user_id}/apikeys`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication apiKeyHeaderAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication apiKeyQueryParamAuth required
            await setApiKeyToObject(localVarQueryParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update API key
         * @param {string} userId 
         * @param {string} keyId 
         * @param {ApiKeyMutation} apiKeyMutation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApiKeyById: async (userId: string, keyId: string, apiKeyMutation: ApiKeyMutation, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateApiKeyById', 'userId', userId)
            // verify required parameter 'keyId' is not null or undefined
            assertParamExists('updateApiKeyById', 'keyId', keyId)
            // verify required parameter 'apiKeyMutation' is not null or undefined
            assertParamExists('updateApiKeyById', 'apiKeyMutation', apiKeyMutation)
            const localVarPath = `/users/{user_id}/apikeys/{key_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"key_id"}}`, encodeURIComponent(String(keyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication apiKeyHeaderAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication apiKeyQueryParamAuth required
            await setApiKeyToObject(localVarQueryParameter, "api_key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiKeyMutation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Authenticate and create access token
         * @param {AuthTokenRequest} authTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAccessToken(authTokenRequest: AuthTokenRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAccessToken(authTokenRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.createAccessToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create API key for the given user. When an API key is created, the `token` value will be exposed in the response. This token can be passed as the `X-API-KEY` header value for future requests. It is not obtainable in other API requests (ie. the client must decide how to keep the API key token in e.g. a vault or similar). 
         * @summary Create API key
         * @param {string} userId 
         * @param {ApiKeyCreation} apiKeyCreation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createApiKey(userId: string, apiKeyCreation: ApiKeyCreation, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateApiKey201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createApiKey(userId, apiKeyCreation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.createApiKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete API key
         * @param {string} userId 
         * @param {string} keyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteApiKeyById(userId: string, keyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteApiKeyById(userId, keyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.deleteApiKeyById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get API key
         * @param {string} userId 
         * @param {string} keyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApiKeyById(userId: string, keyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetApiKeyById200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApiKeyById(userId, keyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.getApiKeyById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List API keys for account
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listApiKeysByAccountId(accountId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListApiKeysByAccountId200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listApiKeysByAccountId(accountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.listApiKeysByAccountId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List API keys for user
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listApiKeysByUserId(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListApiKeysByAccountId200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listApiKeysByUserId(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.listApiKeysByUserId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update API key
         * @param {string} userId 
         * @param {string} keyId 
         * @param {ApiKeyMutation} apiKeyMutation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateApiKeyById(userId: string, keyId: string, apiKeyMutation: ApiKeyMutation, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetApiKeyById200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateApiKeyById(userId, keyId, apiKeyMutation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.updateApiKeyById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * 
         * @summary Authenticate and create access token
         * @param {AuthTokenRequest} authTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccessToken(authTokenRequest: AuthTokenRequest, options?: any): AxiosPromise<AuthTokenResponse> {
            return localVarFp.createAccessToken(authTokenRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create API key for the given user. When an API key is created, the `token` value will be exposed in the response. This token can be passed as the `X-API-KEY` header value for future requests. It is not obtainable in other API requests (ie. the client must decide how to keep the API key token in e.g. a vault or similar). 
         * @summary Create API key
         * @param {string} userId 
         * @param {ApiKeyCreation} apiKeyCreation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApiKey(userId: string, apiKeyCreation: ApiKeyCreation, options?: any): AxiosPromise<CreateApiKey201Response> {
            return localVarFp.createApiKey(userId, apiKeyCreation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete API key
         * @param {string} userId 
         * @param {string} keyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApiKeyById(userId: string, keyId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteApiKeyById(userId, keyId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get API key
         * @param {string} userId 
         * @param {string} keyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiKeyById(userId: string, keyId: string, options?: any): AxiosPromise<GetApiKeyById200Response> {
            return localVarFp.getApiKeyById(userId, keyId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List API keys for account
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApiKeysByAccountId(accountId: string, options?: any): AxiosPromise<ListApiKeysByAccountId200Response> {
            return localVarFp.listApiKeysByAccountId(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List API keys for user
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApiKeysByUserId(userId: string, options?: any): AxiosPromise<ListApiKeysByAccountId200Response> {
            return localVarFp.listApiKeysByUserId(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update API key
         * @param {string} userId 
         * @param {string} keyId 
         * @param {ApiKeyMutation} apiKeyMutation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApiKeyById(userId: string, keyId: string, apiKeyMutation: ApiKeyMutation, options?: any): AxiosPromise<GetApiKeyById200Response> {
            return localVarFp.updateApiKeyById(userId, keyId, apiKeyMutation, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @summary Authenticate and create access token
     * @param {AuthTokenRequest} authTokenRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public createAccessToken(authTokenRequest: AuthTokenRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).createAccessToken(authTokenRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create API key for the given user. When an API key is created, the `token` value will be exposed in the response. This token can be passed as the `X-API-KEY` header value for future requests. It is not obtainable in other API requests (ie. the client must decide how to keep the API key token in e.g. a vault or similar). 
     * @summary Create API key
     * @param {string} userId 
     * @param {ApiKeyCreation} apiKeyCreation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public createApiKey(userId: string, apiKeyCreation: ApiKeyCreation, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).createApiKey(userId, apiKeyCreation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete API key
     * @param {string} userId 
     * @param {string} keyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public deleteApiKeyById(userId: string, keyId: string, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).deleteApiKeyById(userId, keyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get API key
     * @param {string} userId 
     * @param {string} keyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public getApiKeyById(userId: string, keyId: string, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).getApiKeyById(userId, keyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List API keys for account
     * @param {string} accountId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public listApiKeysByAccountId(accountId: string, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).listApiKeysByAccountId(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List API keys for user
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public listApiKeysByUserId(userId: string, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).listApiKeysByUserId(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update API key
     * @param {string} userId 
     * @param {string} keyId 
     * @param {ApiKeyMutation} apiKeyMutation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public updateApiKeyById(userId: string, keyId: string, apiKeyMutation: ApiKeyMutation, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).updateApiKeyById(userId, keyId, apiKeyMutation, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MeasurementClientsApi - axios parameter creator
 * @export
 */
export const MeasurementClientsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a measurement client in the account of the user 
         * @summary Create measurement client
         * @param {MeasurementClientMutation} measurementClientMutation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMeasurementClient: async (measurementClientMutation: MeasurementClientMutation, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'measurementClientMutation' is not null or undefined
            assertParamExists('createMeasurementClient', 'measurementClientMutation', measurementClientMutation)
            const localVarPath = `/measurement/clients`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication apiKeyHeaderAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication apiKeyQueryParamAuth required
            await setApiKeyToObject(localVarQueryParameter, "api_key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(measurementClientMutation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the logo for a client 
         * @summary Delete measurement client logo
         * @param {string} clientId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteClientLogo: async (clientId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('deleteClientLogo', 'clientId', clientId)
            const localVarPath = `/measurement/clients/{client_id}/assets/logo`
                .replace(`{${"client_id"}}`, encodeURIComponent(String(clientId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication apiKeyHeaderAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication apiKeyQueryParamAuth required
            await setApiKeyToObject(localVarQueryParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a measurement client 
         * @summary Delete measurement client
         * @param {string} clientId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMeasurementClientById: async (clientId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('deleteMeasurementClientById', 'clientId', clientId)
            const localVarPath = `/measurement/clients/{client_id}`
                .replace(`{${"client_id"}}`, encodeURIComponent(String(clientId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication apiKeyHeaderAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication apiKeyQueryParamAuth required
            await setApiKeyToObject(localVarQueryParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the client logo, if the image is hosted on the Digiseg platform. Refer to the clients\'s `logo_url` to get a non-authenticated and shareable URL for the logo. 
         * @summary Get measurement client logo
         * @param {string} clientId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClientLogo: async (clientId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('getClientLogo', 'clientId', clientId)
            const localVarPath = `/measurement/clients/{client_id}/assets/logo`
                .replace(`{${"client_id"}}`, encodeURIComponent(String(clientId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication apiKeyHeaderAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication apiKeyQueryParamAuth required
            await setApiKeyToObject(localVarQueryParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information for a specific measurement client 
         * @summary Get measurement client
         * @param {string} clientId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMeasurementClientById: async (clientId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('getMeasurementClientById', 'clientId', clientId)
            const localVarPath = `/measurement/clients/{client_id}`
                .replace(`{${"client_id"}}`, encodeURIComponent(String(clientId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication apiKeyHeaderAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication apiKeyQueryParamAuth required
            await setApiKeyToObject(localVarQueryParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List measurement clients that the user has access to 
         * @summary List measurement clients
         * @param {string} [filterAccountId] Optional parameter used to query measurement clients by specific account IDs (only available to super admins). The value &#x60;*&#x60; is synonymous for \&quot;all accounts\&quot;. 
         * @param {string} [filterNameContains] Optional parameter used to search for clients where the name contains a substring (case insensitive)
         * @param {number} [pageSize] The desired page size
         * @param {string} [pageAfter] Optional pagination parameter, indicating the previous cursor value to paginate beyond. The value to provide here is opaque, but can be found in previous requests in the &#x60;meta.page.last_cursor&#x60; field. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMeasurementClients: async (filterAccountId?: string, filterNameContains?: string, pageSize?: number, pageAfter?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/measurement/clients`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication apiKeyHeaderAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication apiKeyQueryParamAuth required
            await setApiKeyToObject(localVarQueryParameter, "api_key", configuration)

            if (filterAccountId !== undefined) {
                localVarQueryParameter['filter[account_id]'] = filterAccountId;
            }

            if (filterNameContains !== undefined) {
                localVarQueryParameter['filter[name][contains]'] = filterNameContains;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page[size]'] = pageSize;
            }

            if (pageAfter !== undefined) {
                localVarQueryParameter['page[after]'] = pageAfter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates properties of a measurement client 
         * @summary Update measurement client
         * @param {string} clientId 
         * @param {MeasurementClientMutation} measurementClientMutation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMeasurementClientById: async (clientId: string, measurementClientMutation: MeasurementClientMutation, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('updateMeasurementClientById', 'clientId', clientId)
            // verify required parameter 'measurementClientMutation' is not null or undefined
            assertParamExists('updateMeasurementClientById', 'measurementClientMutation', measurementClientMutation)
            const localVarPath = `/measurement/clients/{client_id}`
                .replace(`{${"client_id"}}`, encodeURIComponent(String(clientId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication apiKeyHeaderAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication apiKeyQueryParamAuth required
            await setApiKeyToObject(localVarQueryParameter, "api_key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(measurementClientMutation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload a logo for a client 
         * @summary Upload measurement client logo
         * @param {string} clientId 
         * @param {File} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadClientLogo: async (clientId: string, body: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('uploadClientLogo', 'clientId', clientId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('uploadClientLogo', 'body', body)
            const localVarPath = `/measurement/clients/{client_id}/assets/logo`
                .replace(`{${"client_id"}}`, encodeURIComponent(String(clientId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication apiKeyHeaderAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication apiKeyQueryParamAuth required
            await setApiKeyToObject(localVarQueryParameter, "api_key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'image/gif';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MeasurementClientsApi - functional programming interface
 * @export
 */
export const MeasurementClientsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MeasurementClientsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a measurement client in the account of the user 
         * @summary Create measurement client
         * @param {MeasurementClientMutation} measurementClientMutation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMeasurementClient(measurementClientMutation: MeasurementClientMutation, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateMeasurementClient201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMeasurementClient(measurementClientMutation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MeasurementClientsApi.createMeasurementClient']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes the logo for a client 
         * @summary Delete measurement client logo
         * @param {string} clientId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteClientLogo(clientId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteClientLogo(clientId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MeasurementClientsApi.deleteClientLogo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a measurement client 
         * @summary Delete measurement client
         * @param {string} clientId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMeasurementClientById(clientId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMeasurementClientById(clientId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MeasurementClientsApi.deleteMeasurementClientById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Gets the client logo, if the image is hosted on the Digiseg platform. Refer to the clients\'s `logo_url` to get a non-authenticated and shareable URL for the logo. 
         * @summary Get measurement client logo
         * @param {string} clientId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClientLogo(clientId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getClientLogo(clientId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MeasurementClientsApi.getClientLogo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get information for a specific measurement client 
         * @summary Get measurement client
         * @param {string} clientId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMeasurementClientById(clientId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateMeasurementClient201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMeasurementClientById(clientId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MeasurementClientsApi.getMeasurementClientById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List measurement clients that the user has access to 
         * @summary List measurement clients
         * @param {string} [filterAccountId] Optional parameter used to query measurement clients by specific account IDs (only available to super admins). The value &#x60;*&#x60; is synonymous for \&quot;all accounts\&quot;. 
         * @param {string} [filterNameContains] Optional parameter used to search for clients where the name contains a substring (case insensitive)
         * @param {number} [pageSize] The desired page size
         * @param {string} [pageAfter] Optional pagination parameter, indicating the previous cursor value to paginate beyond. The value to provide here is opaque, but can be found in previous requests in the &#x60;meta.page.last_cursor&#x60; field. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMeasurementClients(filterAccountId?: string, filterNameContains?: string, pageSize?: number, pageAfter?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListMeasurementClients200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMeasurementClients(filterAccountId, filterNameContains, pageSize, pageAfter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MeasurementClientsApi.listMeasurementClients']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates properties of a measurement client 
         * @summary Update measurement client
         * @param {string} clientId 
         * @param {MeasurementClientMutation} measurementClientMutation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMeasurementClientById(clientId: string, measurementClientMutation: MeasurementClientMutation, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateMeasurementClient201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMeasurementClientById(clientId, measurementClientMutation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MeasurementClientsApi.updateMeasurementClientById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Upload a logo for a client 
         * @summary Upload measurement client logo
         * @param {string} clientId 
         * @param {File} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadClientLogo(clientId: string, body: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadClientLogo(clientId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MeasurementClientsApi.uploadClientLogo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MeasurementClientsApi - factory interface
 * @export
 */
export const MeasurementClientsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MeasurementClientsApiFp(configuration)
    return {
        /**
         * Create a measurement client in the account of the user 
         * @summary Create measurement client
         * @param {MeasurementClientMutation} measurementClientMutation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMeasurementClient(measurementClientMutation: MeasurementClientMutation, options?: any): AxiosPromise<CreateMeasurementClient201Response> {
            return localVarFp.createMeasurementClient(measurementClientMutation, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the logo for a client 
         * @summary Delete measurement client logo
         * @param {string} clientId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteClientLogo(clientId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteClientLogo(clientId, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a measurement client 
         * @summary Delete measurement client
         * @param {string} clientId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMeasurementClientById(clientId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteMeasurementClientById(clientId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the client logo, if the image is hosted on the Digiseg platform. Refer to the clients\'s `logo_url` to get a non-authenticated and shareable URL for the logo. 
         * @summary Get measurement client logo
         * @param {string} clientId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClientLogo(clientId: string, options?: any): AxiosPromise<void> {
            return localVarFp.getClientLogo(clientId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get information for a specific measurement client 
         * @summary Get measurement client
         * @param {string} clientId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMeasurementClientById(clientId: string, options?: any): AxiosPromise<CreateMeasurementClient201Response> {
            return localVarFp.getMeasurementClientById(clientId, options).then((request) => request(axios, basePath));
        },
        /**
         * List measurement clients that the user has access to 
         * @summary List measurement clients
         * @param {string} [filterAccountId] Optional parameter used to query measurement clients by specific account IDs (only available to super admins). The value &#x60;*&#x60; is synonymous for \&quot;all accounts\&quot;. 
         * @param {string} [filterNameContains] Optional parameter used to search for clients where the name contains a substring (case insensitive)
         * @param {number} [pageSize] The desired page size
         * @param {string} [pageAfter] Optional pagination parameter, indicating the previous cursor value to paginate beyond. The value to provide here is opaque, but can be found in previous requests in the &#x60;meta.page.last_cursor&#x60; field. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMeasurementClients(filterAccountId?: string, filterNameContains?: string, pageSize?: number, pageAfter?: string, options?: any): AxiosPromise<ListMeasurementClients200Response> {
            return localVarFp.listMeasurementClients(filterAccountId, filterNameContains, pageSize, pageAfter, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates properties of a measurement client 
         * @summary Update measurement client
         * @param {string} clientId 
         * @param {MeasurementClientMutation} measurementClientMutation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMeasurementClientById(clientId: string, measurementClientMutation: MeasurementClientMutation, options?: any): AxiosPromise<CreateMeasurementClient201Response> {
            return localVarFp.updateMeasurementClientById(clientId, measurementClientMutation, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload a logo for a client 
         * @summary Upload measurement client logo
         * @param {string} clientId 
         * @param {File} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadClientLogo(clientId: string, body: File, options?: any): AxiosPromise<void> {
            return localVarFp.uploadClientLogo(clientId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MeasurementClientsApi - object-oriented interface
 * @export
 * @class MeasurementClientsApi
 * @extends {BaseAPI}
 */
export class MeasurementClientsApi extends BaseAPI {
    /**
     * Create a measurement client in the account of the user 
     * @summary Create measurement client
     * @param {MeasurementClientMutation} measurementClientMutation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeasurementClientsApi
     */
    public createMeasurementClient(measurementClientMutation: MeasurementClientMutation, options?: RawAxiosRequestConfig) {
        return MeasurementClientsApiFp(this.configuration).createMeasurementClient(measurementClientMutation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the logo for a client 
     * @summary Delete measurement client logo
     * @param {string} clientId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeasurementClientsApi
     */
    public deleteClientLogo(clientId: string, options?: RawAxiosRequestConfig) {
        return MeasurementClientsApiFp(this.configuration).deleteClientLogo(clientId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a measurement client 
     * @summary Delete measurement client
     * @param {string} clientId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeasurementClientsApi
     */
    public deleteMeasurementClientById(clientId: string, options?: RawAxiosRequestConfig) {
        return MeasurementClientsApiFp(this.configuration).deleteMeasurementClientById(clientId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets the client logo, if the image is hosted on the Digiseg platform. Refer to the clients\'s `logo_url` to get a non-authenticated and shareable URL for the logo. 
     * @summary Get measurement client logo
     * @param {string} clientId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeasurementClientsApi
     */
    public getClientLogo(clientId: string, options?: RawAxiosRequestConfig) {
        return MeasurementClientsApiFp(this.configuration).getClientLogo(clientId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get information for a specific measurement client 
     * @summary Get measurement client
     * @param {string} clientId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeasurementClientsApi
     */
    public getMeasurementClientById(clientId: string, options?: RawAxiosRequestConfig) {
        return MeasurementClientsApiFp(this.configuration).getMeasurementClientById(clientId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List measurement clients that the user has access to 
     * @summary List measurement clients
     * @param {string} [filterAccountId] Optional parameter used to query measurement clients by specific account IDs (only available to super admins). The value &#x60;*&#x60; is synonymous for \&quot;all accounts\&quot;. 
     * @param {string} [filterNameContains] Optional parameter used to search for clients where the name contains a substring (case insensitive)
     * @param {number} [pageSize] The desired page size
     * @param {string} [pageAfter] Optional pagination parameter, indicating the previous cursor value to paginate beyond. The value to provide here is opaque, but can be found in previous requests in the &#x60;meta.page.last_cursor&#x60; field. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeasurementClientsApi
     */
    public listMeasurementClients(filterAccountId?: string, filterNameContains?: string, pageSize?: number, pageAfter?: string, options?: RawAxiosRequestConfig) {
        return MeasurementClientsApiFp(this.configuration).listMeasurementClients(filterAccountId, filterNameContains, pageSize, pageAfter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates properties of a measurement client 
     * @summary Update measurement client
     * @param {string} clientId 
     * @param {MeasurementClientMutation} measurementClientMutation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeasurementClientsApi
     */
    public updateMeasurementClientById(clientId: string, measurementClientMutation: MeasurementClientMutation, options?: RawAxiosRequestConfig) {
        return MeasurementClientsApiFp(this.configuration).updateMeasurementClientById(clientId, measurementClientMutation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload a logo for a client 
     * @summary Upload measurement client logo
     * @param {string} clientId 
     * @param {File} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeasurementClientsApi
     */
    public uploadClientLogo(clientId: string, body: File, options?: RawAxiosRequestConfig) {
        return MeasurementClientsApiFp(this.configuration).uploadClientLogo(clientId, body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MeasurementLabelsApi - axios parameter creator
 * @export
 */
export const MeasurementLabelsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List measurement labels that the user has access to 
         * @summary List measurement labels
         * @param {string} [filterAccountId] Optional parameter used to query measurement labels by specific account IDs (only available to super admins). The value &#x60;*&#x60; is synonymous for \&quot;all accounts\&quot;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMeasurementLabels: async (filterAccountId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/measurement/labels`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication apiKeyHeaderAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication apiKeyQueryParamAuth required
            await setApiKeyToObject(localVarQueryParameter, "api_key", configuration)

            if (filterAccountId !== undefined) {
                localVarQueryParameter['filter[account_id]'] = filterAccountId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MeasurementLabelsApi - functional programming interface
 * @export
 */
export const MeasurementLabelsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MeasurementLabelsApiAxiosParamCreator(configuration)
    return {
        /**
         * List measurement labels that the user has access to 
         * @summary List measurement labels
         * @param {string} [filterAccountId] Optional parameter used to query measurement labels by specific account IDs (only available to super admins). The value &#x60;*&#x60; is synonymous for \&quot;all accounts\&quot;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMeasurementLabels(filterAccountId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListMeasurementLabels200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMeasurementLabels(filterAccountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MeasurementLabelsApi.listMeasurementLabels']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MeasurementLabelsApi - factory interface
 * @export
 */
export const MeasurementLabelsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MeasurementLabelsApiFp(configuration)
    return {
        /**
         * List measurement labels that the user has access to 
         * @summary List measurement labels
         * @param {string} [filterAccountId] Optional parameter used to query measurement labels by specific account IDs (only available to super admins). The value &#x60;*&#x60; is synonymous for \&quot;all accounts\&quot;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMeasurementLabels(filterAccountId?: string, options?: any): AxiosPromise<ListMeasurementLabels200Response> {
            return localVarFp.listMeasurementLabels(filterAccountId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MeasurementLabelsApi - object-oriented interface
 * @export
 * @class MeasurementLabelsApi
 * @extends {BaseAPI}
 */
export class MeasurementLabelsApi extends BaseAPI {
    /**
     * List measurement labels that the user has access to 
     * @summary List measurement labels
     * @param {string} [filterAccountId] Optional parameter used to query measurement labels by specific account IDs (only available to super admins). The value &#x60;*&#x60; is synonymous for \&quot;all accounts\&quot;. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeasurementLabelsApi
     */
    public listMeasurementLabels(filterAccountId?: string, options?: RawAxiosRequestConfig) {
        return MeasurementLabelsApiFp(this.configuration).listMeasurementLabels(filterAccountId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PopulationsApi - axios parameter creator
 * @export
 */
export const PopulationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get population data referenced by a specific key.
         * @summary Get Population by key
         * @param {string} categoryKey An identifier for the category
         * @param {string} populationKey An identifier for the population
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPopuplationByKey: async (categoryKey: string, populationKey: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryKey' is not null or undefined
            assertParamExists('getPopuplationByKey', 'categoryKey', categoryKey)
            // verify required parameter 'populationKey' is not null or undefined
            assertParamExists('getPopuplationByKey', 'populationKey', populationKey)
            const localVarPath = `/populations/{category_key}/{population_key}`
                .replace(`{${"category_key"}}`, encodeURIComponent(String(categoryKey)))
                .replace(`{${"population_key"}}`, encodeURIComponent(String(populationKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication apiKeyHeaderAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication apiKeyQueryParamAuth required
            await setApiKeyToObject(localVarQueryParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all populations within a category
         * @summary List populations of category
         * @param {string} categoryKey An identifier for the category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPopuplations: async (categoryKey: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryKey' is not null or undefined
            assertParamExists('listPopuplations', 'categoryKey', categoryKey)
            const localVarPath = `/populations/{category_key}`
                .replace(`{${"category_key"}}`, encodeURIComponent(String(categoryKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication apiKeyHeaderAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication apiKeyQueryParamAuth required
            await setApiKeyToObject(localVarQueryParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PopulationsApi - functional programming interface
 * @export
 */
export const PopulationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PopulationsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get population data referenced by a specific key.
         * @summary Get Population by key
         * @param {string} categoryKey An identifier for the category
         * @param {string} populationKey An identifier for the population
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPopuplationByKey(categoryKey: string, populationKey: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPopuplationByKey200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPopuplationByKey(categoryKey, populationKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PopulationsApi.getPopuplationByKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all populations within a category
         * @summary List populations of category
         * @param {string} categoryKey An identifier for the category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPopuplations(categoryKey: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListPopuplations200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPopuplations(categoryKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PopulationsApi.listPopuplations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PopulationsApi - factory interface
 * @export
 */
export const PopulationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PopulationsApiFp(configuration)
    return {
        /**
         * Get population data referenced by a specific key.
         * @summary Get Population by key
         * @param {string} categoryKey An identifier for the category
         * @param {string} populationKey An identifier for the population
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPopuplationByKey(categoryKey: string, populationKey: string, options?: any): AxiosPromise<GetPopuplationByKey200Response> {
            return localVarFp.getPopuplationByKey(categoryKey, populationKey, options).then((request) => request(axios, basePath));
        },
        /**
         * List all populations within a category
         * @summary List populations of category
         * @param {string} categoryKey An identifier for the category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPopuplations(categoryKey: string, options?: any): AxiosPromise<ListPopuplations200Response> {
            return localVarFp.listPopuplations(categoryKey, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PopulationsApi - object-oriented interface
 * @export
 * @class PopulationsApi
 * @extends {BaseAPI}
 */
export class PopulationsApi extends BaseAPI {
    /**
     * Get population data referenced by a specific key.
     * @summary Get Population by key
     * @param {string} categoryKey An identifier for the category
     * @param {string} populationKey An identifier for the population
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PopulationsApi
     */
    public getPopuplationByKey(categoryKey: string, populationKey: string, options?: RawAxiosRequestConfig) {
        return PopulationsApiFp(this.configuration).getPopuplationByKey(categoryKey, populationKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all populations within a category
     * @summary List populations of category
     * @param {string} categoryKey An identifier for the category
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PopulationsApi
     */
    public listPopuplations(categoryKey: string, options?: RawAxiosRequestConfig) {
        return PopulationsApiFp(this.configuration).listPopuplations(categoryKey, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * StudiesApi - axios parameter creator
 * @export
 */
export const StudiesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new study
         * @summary Create study
         * @param {StudyCreation} studyCreation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStudy: async (studyCreation: StudyCreation, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'studyCreation' is not null or undefined
            assertParamExists('createStudy', 'studyCreation', studyCreation)
            const localVarPath = `/studies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication apiKeyHeaderAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication apiKeyQueryParamAuth required
            await setApiKeyToObject(localVarQueryParameter, "api_key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(studyCreation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the banner image for a study 
         * @summary Delete study banner image logo
         * @param {string} studyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteStudyBannerImage: async (studyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'studyId' is not null or undefined
            assertParamExists('deleteStudyBannerImage', 'studyId', studyId)
            const localVarPath = `/studies/{study_id}/assets/banner_image`
                .replace(`{${"study_id"}}`, encodeURIComponent(String(studyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication apiKeyHeaderAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication apiKeyQueryParamAuth required
            await setApiKeyToObject(localVarQueryParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a study 
         * @summary Delete study
         * @param {string} studyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteStudyById: async (studyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'studyId' is not null or undefined
            assertParamExists('deleteStudyById', 'studyId', studyId)
            const localVarPath = `/studies/{study_id}`
                .replace(`{${"study_id"}}`, encodeURIComponent(String(studyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication apiKeyHeaderAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication apiKeyQueryParamAuth required
            await setApiKeyToObject(localVarQueryParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the study banner image, if the image is hosted on the Digiseg platform. Refer to the study\'s `banner_image_url` to get a non-authenticated and shareable URL for the logo. 
         * @summary Get study banner image
         * @param {string} studyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudyBannerImage: async (studyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'studyId' is not null or undefined
            assertParamExists('getStudyBannerImage', 'studyId', studyId)
            const localVarPath = `/studies/{study_id}/assets/banner_image`
                .replace(`{${"study_id"}}`, encodeURIComponent(String(studyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication apiKeyHeaderAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication apiKeyQueryParamAuth required
            await setApiKeyToObject(localVarQueryParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get study information for a specific study 
         * @summary Get study
         * @param {string} studyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudyById: async (studyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'studyId' is not null or undefined
            assertParamExists('getStudyById', 'studyId', studyId)
            const localVarPath = `/studies/{study_id}`
                .replace(`{${"study_id"}}`, encodeURIComponent(String(studyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication apiKeyHeaderAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication apiKeyQueryParamAuth required
            await setApiKeyToObject(localVarQueryParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List studies that the user has access to 
         * @summary List studies
         * @param {ListStudiesSortEnum} [sort] Defines the field to sort the result items by. Ascending order is applied by default, but the minus character can be used to indicate descending order instead. 
         * @param {boolean} [filterIsExample] Optional parameter used to filter for example studies
         * @param {string} [filterLabel] Optional parameter used to filter by study label
         * @param {string} [filterNameContains] Optional parameter used to search for studies where the name contains a substring (case insensitive)
         * @param {string} [filterAccountId] Optional parameter used to query studies by specific account IDs (only available to super admins). The value &#x60;*&#x60; is synonymous for \&quot;all accounts\&quot;. 
         * @param {number} [pageSize] The desired page size
         * @param {string} [pageAfter] Optional pagination parameter, indicating the previous cursor value to paginate beyond. The value to provide here is opaque, but can be found in previous requests in the &#x60;meta.page.last_cursor&#x60; field. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listStudies: async (sort?: ListStudiesSortEnum, filterIsExample?: boolean, filterLabel?: string, filterNameContains?: string, filterAccountId?: string, pageSize?: number, pageAfter?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/studies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication apiKeyHeaderAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication apiKeyQueryParamAuth required
            await setApiKeyToObject(localVarQueryParameter, "api_key", configuration)

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (filterIsExample !== undefined) {
                localVarQueryParameter['filter[is_example]'] = filterIsExample;
            }

            if (filterLabel !== undefined) {
                localVarQueryParameter['filter[label]'] = filterLabel;
            }

            if (filterNameContains !== undefined) {
                localVarQueryParameter['filter[name][contains]'] = filterNameContains;
            }

            if (filterAccountId !== undefined) {
                localVarQueryParameter['filter[account_id]'] = filterAccountId;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page[size]'] = pageSize;
            }

            if (pageAfter !== undefined) {
                localVarQueryParameter['page[after]'] = pageAfter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query the audience statistics for a study, enabling the user to see the representation of matched household characteristics to impressions and clicks. These statistics can be compared to the Average Internet Population (globally or for a specific country), or to the audience stats of other studies. 
         * @summary Audience statistics for study
         * @param {string} studyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryStudyAudienceStats: async (studyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'studyId' is not null or undefined
            assertParamExists('queryStudyAudienceStats', 'studyId', studyId)
            const localVarPath = `/studies/{study_id}/stats/audiences`
                .replace(`{${"study_id"}}`, encodeURIComponent(String(studyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication apiKeyHeaderAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication apiKeyQueryParamAuth required
            await setApiKeyToObject(localVarQueryParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query the country statistics for a study, enabling the user to see where the study is being delivered. 
         * @summary Country statistics for study
         * @param {string} studyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryStudyCountryStats: async (studyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'studyId' is not null or undefined
            assertParamExists('queryStudyCountryStats', 'studyId', studyId)
            const localVarPath = `/studies/{study_id}/stats/countries`
                .replace(`{${"study_id"}}`, encodeURIComponent(String(studyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication apiKeyHeaderAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication apiKeyQueryParamAuth required
            await setApiKeyToObject(localVarQueryParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query the frequency statistics for a study. Frequency statistics are helpful to identify the frequency of impressions per user, or distinct reach of a study. It can also be helpful to identify how multiple impressions for the same users may or may not generate more clicks. 
         * @summary Frequency statistics for study
         * @param {string} studyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryStudyFrequencyStats: async (studyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'studyId' is not null or undefined
            assertParamExists('queryStudyFrequencyStats', 'studyId', studyId)
            const localVarPath = `/studies/{study_id}/stats/frequencies`
                .replace(`{${"study_id"}}`, encodeURIComponent(String(studyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication apiKeyHeaderAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication apiKeyQueryParamAuth required
            await setApiKeyToObject(localVarQueryParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query the timing statistics for a study, enabling the user to see performance and delivery figures at different times of day, days of the week and days of the month. 
         * @summary Timing statistics for study
         * @param {string} studyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryStudyTimingStats: async (studyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'studyId' is not null or undefined
            assertParamExists('queryStudyTimingStats', 'studyId', studyId)
            const localVarPath = `/studies/{study_id}/stats/timing`
                .replace(`{${"study_id"}}`, encodeURIComponent(String(studyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication apiKeyHeaderAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication apiKeyQueryParamAuth required
            await setApiKeyToObject(localVarQueryParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates properties of a study 
         * @summary Update study
         * @param {string} studyId 
         * @param {StudyMutation} studyMutation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStudyById: async (studyId: string, studyMutation: StudyMutation, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'studyId' is not null or undefined
            assertParamExists('updateStudyById', 'studyId', studyId)
            // verify required parameter 'studyMutation' is not null or undefined
            assertParamExists('updateStudyById', 'studyMutation', studyMutation)
            const localVarPath = `/studies/{study_id}`
                .replace(`{${"study_id"}}`, encodeURIComponent(String(studyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication apiKeyHeaderAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication apiKeyQueryParamAuth required
            await setApiKeyToObject(localVarQueryParameter, "api_key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(studyMutation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload a banner image for a study 
         * @summary Upload study banner image
         * @param {string} studyId 
         * @param {File} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadStudyBannerImage: async (studyId: string, body: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'studyId' is not null or undefined
            assertParamExists('uploadStudyBannerImage', 'studyId', studyId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('uploadStudyBannerImage', 'body', body)
            const localVarPath = `/studies/{study_id}/assets/banner_image`
                .replace(`{${"study_id"}}`, encodeURIComponent(String(studyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication apiKeyHeaderAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication apiKeyQueryParamAuth required
            await setApiKeyToObject(localVarQueryParameter, "api_key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'image/gif';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StudiesApi - functional programming interface
 * @export
 */
export const StudiesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StudiesApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new study
         * @summary Create study
         * @param {StudyCreation} studyCreation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createStudy(studyCreation: StudyCreation, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateStudy201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createStudy(studyCreation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StudiesApi.createStudy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes the banner image for a study 
         * @summary Delete study banner image logo
         * @param {string} studyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteStudyBannerImage(studyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteStudyBannerImage(studyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StudiesApi.deleteStudyBannerImage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a study 
         * @summary Delete study
         * @param {string} studyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteStudyById(studyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteStudyById(studyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StudiesApi.deleteStudyById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Gets the study banner image, if the image is hosted on the Digiseg platform. Refer to the study\'s `banner_image_url` to get a non-authenticated and shareable URL for the logo. 
         * @summary Get study banner image
         * @param {string} studyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStudyBannerImage(studyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStudyBannerImage(studyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StudiesApi.getStudyBannerImage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get study information for a specific study 
         * @summary Get study
         * @param {string} studyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStudyById(studyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateStudy201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStudyById(studyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StudiesApi.getStudyById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List studies that the user has access to 
         * @summary List studies
         * @param {ListStudiesSortEnum} [sort] Defines the field to sort the result items by. Ascending order is applied by default, but the minus character can be used to indicate descending order instead. 
         * @param {boolean} [filterIsExample] Optional parameter used to filter for example studies
         * @param {string} [filterLabel] Optional parameter used to filter by study label
         * @param {string} [filterNameContains] Optional parameter used to search for studies where the name contains a substring (case insensitive)
         * @param {string} [filterAccountId] Optional parameter used to query studies by specific account IDs (only available to super admins). The value &#x60;*&#x60; is synonymous for \&quot;all accounts\&quot;. 
         * @param {number} [pageSize] The desired page size
         * @param {string} [pageAfter] Optional pagination parameter, indicating the previous cursor value to paginate beyond. The value to provide here is opaque, but can be found in previous requests in the &#x60;meta.page.last_cursor&#x60; field. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listStudies(sort?: ListStudiesSortEnum, filterIsExample?: boolean, filterLabel?: string, filterNameContains?: string, filterAccountId?: string, pageSize?: number, pageAfter?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListStudies200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listStudies(sort, filterIsExample, filterLabel, filterNameContains, filterAccountId, pageSize, pageAfter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StudiesApi.listStudies']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query the audience statistics for a study, enabling the user to see the representation of matched household characteristics to impressions and clicks. These statistics can be compared to the Average Internet Population (globally or for a specific country), or to the audience stats of other studies. 
         * @summary Audience statistics for study
         * @param {string} studyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queryStudyAudienceStats(studyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryStudyAudienceStats200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.queryStudyAudienceStats(studyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StudiesApi.queryStudyAudienceStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query the country statistics for a study, enabling the user to see where the study is being delivered. 
         * @summary Country statistics for study
         * @param {string} studyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queryStudyCountryStats(studyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryStudyCountryStats200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.queryStudyCountryStats(studyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StudiesApi.queryStudyCountryStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query the frequency statistics for a study. Frequency statistics are helpful to identify the frequency of impressions per user, or distinct reach of a study. It can also be helpful to identify how multiple impressions for the same users may or may not generate more clicks. 
         * @summary Frequency statistics for study
         * @param {string} studyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queryStudyFrequencyStats(studyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryStudyFrequencyStats200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.queryStudyFrequencyStats(studyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StudiesApi.queryStudyFrequencyStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query the timing statistics for a study, enabling the user to see performance and delivery figures at different times of day, days of the week and days of the month. 
         * @summary Timing statistics for study
         * @param {string} studyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queryStudyTimingStats(studyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryStudyTimingStats200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.queryStudyTimingStats(studyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StudiesApi.queryStudyTimingStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates properties of a study 
         * @summary Update study
         * @param {string} studyId 
         * @param {StudyMutation} studyMutation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateStudyById(studyId: string, studyMutation: StudyMutation, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateStudy201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateStudyById(studyId, studyMutation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StudiesApi.updateStudyById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Upload a banner image for a study 
         * @summary Upload study banner image
         * @param {string} studyId 
         * @param {File} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadStudyBannerImage(studyId: string, body: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadStudyBannerImage(studyId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StudiesApi.uploadStudyBannerImage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * StudiesApi - factory interface
 * @export
 */
export const StudiesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StudiesApiFp(configuration)
    return {
        /**
         * Create a new study
         * @summary Create study
         * @param {StudyCreation} studyCreation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStudy(studyCreation: StudyCreation, options?: any): AxiosPromise<CreateStudy201Response> {
            return localVarFp.createStudy(studyCreation, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the banner image for a study 
         * @summary Delete study banner image logo
         * @param {string} studyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteStudyBannerImage(studyId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteStudyBannerImage(studyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a study 
         * @summary Delete study
         * @param {string} studyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteStudyById(studyId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteStudyById(studyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the study banner image, if the image is hosted on the Digiseg platform. Refer to the study\'s `banner_image_url` to get a non-authenticated and shareable URL for the logo. 
         * @summary Get study banner image
         * @param {string} studyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudyBannerImage(studyId: string, options?: any): AxiosPromise<void> {
            return localVarFp.getStudyBannerImage(studyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get study information for a specific study 
         * @summary Get study
         * @param {string} studyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudyById(studyId: string, options?: any): AxiosPromise<CreateStudy201Response> {
            return localVarFp.getStudyById(studyId, options).then((request) => request(axios, basePath));
        },
        /**
         * List studies that the user has access to 
         * @summary List studies
         * @param {ListStudiesSortEnum} [sort] Defines the field to sort the result items by. Ascending order is applied by default, but the minus character can be used to indicate descending order instead. 
         * @param {boolean} [filterIsExample] Optional parameter used to filter for example studies
         * @param {string} [filterLabel] Optional parameter used to filter by study label
         * @param {string} [filterNameContains] Optional parameter used to search for studies where the name contains a substring (case insensitive)
         * @param {string} [filterAccountId] Optional parameter used to query studies by specific account IDs (only available to super admins). The value &#x60;*&#x60; is synonymous for \&quot;all accounts\&quot;. 
         * @param {number} [pageSize] The desired page size
         * @param {string} [pageAfter] Optional pagination parameter, indicating the previous cursor value to paginate beyond. The value to provide here is opaque, but can be found in previous requests in the &#x60;meta.page.last_cursor&#x60; field. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listStudies(sort?: ListStudiesSortEnum, filterIsExample?: boolean, filterLabel?: string, filterNameContains?: string, filterAccountId?: string, pageSize?: number, pageAfter?: string, options?: any): AxiosPromise<ListStudies200Response> {
            return localVarFp.listStudies(sort, filterIsExample, filterLabel, filterNameContains, filterAccountId, pageSize, pageAfter, options).then((request) => request(axios, basePath));
        },
        /**
         * Query the audience statistics for a study, enabling the user to see the representation of matched household characteristics to impressions and clicks. These statistics can be compared to the Average Internet Population (globally or for a specific country), or to the audience stats of other studies. 
         * @summary Audience statistics for study
         * @param {string} studyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryStudyAudienceStats(studyId: string, options?: any): AxiosPromise<QueryStudyAudienceStats200Response> {
            return localVarFp.queryStudyAudienceStats(studyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Query the country statistics for a study, enabling the user to see where the study is being delivered. 
         * @summary Country statistics for study
         * @param {string} studyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryStudyCountryStats(studyId: string, options?: any): AxiosPromise<QueryStudyCountryStats200Response> {
            return localVarFp.queryStudyCountryStats(studyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Query the frequency statistics for a study. Frequency statistics are helpful to identify the frequency of impressions per user, or distinct reach of a study. It can also be helpful to identify how multiple impressions for the same users may or may not generate more clicks. 
         * @summary Frequency statistics for study
         * @param {string} studyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryStudyFrequencyStats(studyId: string, options?: any): AxiosPromise<QueryStudyFrequencyStats200Response> {
            return localVarFp.queryStudyFrequencyStats(studyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Query the timing statistics for a study, enabling the user to see performance and delivery figures at different times of day, days of the week and days of the month. 
         * @summary Timing statistics for study
         * @param {string} studyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryStudyTimingStats(studyId: string, options?: any): AxiosPromise<QueryStudyTimingStats200Response> {
            return localVarFp.queryStudyTimingStats(studyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates properties of a study 
         * @summary Update study
         * @param {string} studyId 
         * @param {StudyMutation} studyMutation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStudyById(studyId: string, studyMutation: StudyMutation, options?: any): AxiosPromise<CreateStudy201Response> {
            return localVarFp.updateStudyById(studyId, studyMutation, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload a banner image for a study 
         * @summary Upload study banner image
         * @param {string} studyId 
         * @param {File} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadStudyBannerImage(studyId: string, body: File, options?: any): AxiosPromise<void> {
            return localVarFp.uploadStudyBannerImage(studyId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StudiesApi - object-oriented interface
 * @export
 * @class StudiesApi
 * @extends {BaseAPI}
 */
export class StudiesApi extends BaseAPI {
    /**
     * Create a new study
     * @summary Create study
     * @param {StudyCreation} studyCreation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudiesApi
     */
    public createStudy(studyCreation: StudyCreation, options?: RawAxiosRequestConfig) {
        return StudiesApiFp(this.configuration).createStudy(studyCreation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the banner image for a study 
     * @summary Delete study banner image logo
     * @param {string} studyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudiesApi
     */
    public deleteStudyBannerImage(studyId: string, options?: RawAxiosRequestConfig) {
        return StudiesApiFp(this.configuration).deleteStudyBannerImage(studyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a study 
     * @summary Delete study
     * @param {string} studyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudiesApi
     */
    public deleteStudyById(studyId: string, options?: RawAxiosRequestConfig) {
        return StudiesApiFp(this.configuration).deleteStudyById(studyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets the study banner image, if the image is hosted on the Digiseg platform. Refer to the study\'s `banner_image_url` to get a non-authenticated and shareable URL for the logo. 
     * @summary Get study banner image
     * @param {string} studyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudiesApi
     */
    public getStudyBannerImage(studyId: string, options?: RawAxiosRequestConfig) {
        return StudiesApiFp(this.configuration).getStudyBannerImage(studyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get study information for a specific study 
     * @summary Get study
     * @param {string} studyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudiesApi
     */
    public getStudyById(studyId: string, options?: RawAxiosRequestConfig) {
        return StudiesApiFp(this.configuration).getStudyById(studyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List studies that the user has access to 
     * @summary List studies
     * @param {ListStudiesSortEnum} [sort] Defines the field to sort the result items by. Ascending order is applied by default, but the minus character can be used to indicate descending order instead. 
     * @param {boolean} [filterIsExample] Optional parameter used to filter for example studies
     * @param {string} [filterLabel] Optional parameter used to filter by study label
     * @param {string} [filterNameContains] Optional parameter used to search for studies where the name contains a substring (case insensitive)
     * @param {string} [filterAccountId] Optional parameter used to query studies by specific account IDs (only available to super admins). The value &#x60;*&#x60; is synonymous for \&quot;all accounts\&quot;. 
     * @param {number} [pageSize] The desired page size
     * @param {string} [pageAfter] Optional pagination parameter, indicating the previous cursor value to paginate beyond. The value to provide here is opaque, but can be found in previous requests in the &#x60;meta.page.last_cursor&#x60; field. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudiesApi
     */
    public listStudies(sort?: ListStudiesSortEnum, filterIsExample?: boolean, filterLabel?: string, filterNameContains?: string, filterAccountId?: string, pageSize?: number, pageAfter?: string, options?: RawAxiosRequestConfig) {
        return StudiesApiFp(this.configuration).listStudies(sort, filterIsExample, filterLabel, filterNameContains, filterAccountId, pageSize, pageAfter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query the audience statistics for a study, enabling the user to see the representation of matched household characteristics to impressions and clicks. These statistics can be compared to the Average Internet Population (globally or for a specific country), or to the audience stats of other studies. 
     * @summary Audience statistics for study
     * @param {string} studyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudiesApi
     */
    public queryStudyAudienceStats(studyId: string, options?: RawAxiosRequestConfig) {
        return StudiesApiFp(this.configuration).queryStudyAudienceStats(studyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query the country statistics for a study, enabling the user to see where the study is being delivered. 
     * @summary Country statistics for study
     * @param {string} studyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudiesApi
     */
    public queryStudyCountryStats(studyId: string, options?: RawAxiosRequestConfig) {
        return StudiesApiFp(this.configuration).queryStudyCountryStats(studyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query the frequency statistics for a study. Frequency statistics are helpful to identify the frequency of impressions per user, or distinct reach of a study. It can also be helpful to identify how multiple impressions for the same users may or may not generate more clicks. 
     * @summary Frequency statistics for study
     * @param {string} studyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudiesApi
     */
    public queryStudyFrequencyStats(studyId: string, options?: RawAxiosRequestConfig) {
        return StudiesApiFp(this.configuration).queryStudyFrequencyStats(studyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query the timing statistics for a study, enabling the user to see performance and delivery figures at different times of day, days of the week and days of the month. 
     * @summary Timing statistics for study
     * @param {string} studyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudiesApi
     */
    public queryStudyTimingStats(studyId: string, options?: RawAxiosRequestConfig) {
        return StudiesApiFp(this.configuration).queryStudyTimingStats(studyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates properties of a study 
     * @summary Update study
     * @param {string} studyId 
     * @param {StudyMutation} studyMutation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudiesApi
     */
    public updateStudyById(studyId: string, studyMutation: StudyMutation, options?: RawAxiosRequestConfig) {
        return StudiesApiFp(this.configuration).updateStudyById(studyId, studyMutation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload a banner image for a study 
     * @summary Upload study banner image
     * @param {string} studyId 
     * @param {File} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudiesApi
     */
    public uploadStudyBannerImage(studyId: string, body: File, options?: RawAxiosRequestConfig) {
        return StudiesApiFp(this.configuration).uploadStudyBannerImage(studyId, body, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ListStudiesSortEnum = {
    CreatedAt: 'created_at',
    CreatedAt2: '-created_at',
    Name: 'name',
    Name2: '-name'
} as const;
export type ListStudiesSortEnum = typeof ListStudiesSortEnum[keyof typeof ListStudiesSortEnum];


/**
 * SubscriptionsApi - axios parameter creator
 * @export
 */
export const SubscriptionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets a specific subscription for an account
         * @summary Get account subscription
         * @param {string} accountId 
         * @param {string} subscriptionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountSubscriptionById: async (accountId: string, subscriptionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getAccountSubscriptionById', 'accountId', accountId)
            // verify required parameter 'subscriptionId' is not null or undefined
            assertParamExists('getAccountSubscriptionById', 'subscriptionId', subscriptionId)
            const localVarPath = `/accounts/{account_id}/subscriptions/{subscription_id}`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"subscription_id"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication apiKeyHeaderAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication apiKeyQueryParamAuth required
            await setApiKeyToObject(localVarQueryParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a summary of subscriptions for an account
         * @summary Get account subscriptions summary
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountSubscriptions: async (accountId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getAccountSubscriptions', 'accountId', accountId)
            const localVarPath = `/accounts/{account_id}/subscriptions`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication apiKeyHeaderAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication apiKeyQueryParamAuth required
            await setApiKeyToObject(localVarQueryParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List subscription plans
         * @param {number} [pageSize] The desired page size
         * @param {string} [pageAfter] Optional pagination parameter, indicating the previous cursor value to paginate beyond. The value to provide here is opaque, but can be found in previous requests in the &#x60;meta.page.last_cursor&#x60; field. 
         * @param {boolean} [filterIsPublic] Optional parameter used to filter on the &#x60;is_public&#x60; field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSubscriptionPlans: async (pageSize?: number, pageAfter?: string, filterIsPublic?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/subscription_plans`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication apiKeyHeaderAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication apiKeyQueryParamAuth required
            await setApiKeyToObject(localVarQueryParameter, "api_key", configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['page[size]'] = pageSize;
            }

            if (pageAfter !== undefined) {
                localVarQueryParameter['page[after]'] = pageAfter;
            }

            if (filterIsPublic !== undefined) {
                localVarQueryParameter['filter[is_public]'] = filterIsPublic;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SubscriptionsApi - functional programming interface
 * @export
 */
export const SubscriptionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SubscriptionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Gets a specific subscription for an account
         * @summary Get account subscription
         * @param {string} accountId 
         * @param {string} subscriptionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountSubscriptionById(accountId: string, subscriptionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAccountSubscriptionById200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountSubscriptionById(accountId, subscriptionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionsApi.getAccountSubscriptionById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a summary of subscriptions for an account
         * @summary Get account subscriptions summary
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountSubscriptions(accountId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAccountSubscriptions200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountSubscriptions(accountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionsApi.getAccountSubscriptions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List subscription plans
         * @param {number} [pageSize] The desired page size
         * @param {string} [pageAfter] Optional pagination parameter, indicating the previous cursor value to paginate beyond. The value to provide here is opaque, but can be found in previous requests in the &#x60;meta.page.last_cursor&#x60; field. 
         * @param {boolean} [filterIsPublic] Optional parameter used to filter on the &#x60;is_public&#x60; field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSubscriptionPlans(pageSize?: number, pageAfter?: string, filterIsPublic?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListSubscriptionPlans200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSubscriptionPlans(pageSize, pageAfter, filterIsPublic, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionsApi.listSubscriptionPlans']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SubscriptionsApi - factory interface
 * @export
 */
export const SubscriptionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SubscriptionsApiFp(configuration)
    return {
        /**
         * Gets a specific subscription for an account
         * @summary Get account subscription
         * @param {string} accountId 
         * @param {string} subscriptionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountSubscriptionById(accountId: string, subscriptionId: string, options?: any): AxiosPromise<GetAccountSubscriptionById200Response> {
            return localVarFp.getAccountSubscriptionById(accountId, subscriptionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a summary of subscriptions for an account
         * @summary Get account subscriptions summary
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountSubscriptions(accountId: string, options?: any): AxiosPromise<GetAccountSubscriptions200Response> {
            return localVarFp.getAccountSubscriptions(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List subscription plans
         * @param {number} [pageSize] The desired page size
         * @param {string} [pageAfter] Optional pagination parameter, indicating the previous cursor value to paginate beyond. The value to provide here is opaque, but can be found in previous requests in the &#x60;meta.page.last_cursor&#x60; field. 
         * @param {boolean} [filterIsPublic] Optional parameter used to filter on the &#x60;is_public&#x60; field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSubscriptionPlans(pageSize?: number, pageAfter?: string, filterIsPublic?: boolean, options?: any): AxiosPromise<ListSubscriptionPlans200Response> {
            return localVarFp.listSubscriptionPlans(pageSize, pageAfter, filterIsPublic, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SubscriptionsApi - object-oriented interface
 * @export
 * @class SubscriptionsApi
 * @extends {BaseAPI}
 */
export class SubscriptionsApi extends BaseAPI {
    /**
     * Gets a specific subscription for an account
     * @summary Get account subscription
     * @param {string} accountId 
     * @param {string} subscriptionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public getAccountSubscriptionById(accountId: string, subscriptionId: string, options?: RawAxiosRequestConfig) {
        return SubscriptionsApiFp(this.configuration).getAccountSubscriptionById(accountId, subscriptionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a summary of subscriptions for an account
     * @summary Get account subscriptions summary
     * @param {string} accountId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public getAccountSubscriptions(accountId: string, options?: RawAxiosRequestConfig) {
        return SubscriptionsApiFp(this.configuration).getAccountSubscriptions(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List subscription plans
     * @param {number} [pageSize] The desired page size
     * @param {string} [pageAfter] Optional pagination parameter, indicating the previous cursor value to paginate beyond. The value to provide here is opaque, but can be found in previous requests in the &#x60;meta.page.last_cursor&#x60; field. 
     * @param {boolean} [filterIsPublic] Optional parameter used to filter on the &#x60;is_public&#x60; field
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public listSubscriptionPlans(pageSize?: number, pageAfter?: string, filterIsPublic?: boolean, options?: RawAxiosRequestConfig) {
        return SubscriptionsApiFp(this.configuration).listSubscriptionPlans(pageSize, pageAfter, filterIsPublic, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsageApi - axios parameter creator
 * @export
 */
export const UsageApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Provides usage stats on a daily basis. Results available for the last 2 months.
         * @summary List daily usage of Audience Data
         * @param {string} [filterDateFrom] Date to query from
         * @param {string} [filterDateTo] Date to query to
         * @param {string} [filterAccountId] Optional parameter used to query usage of specific account IDs (only available to super admins). 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAudienceDataDailyUsage: async (filterDateFrom?: string, filterDateTo?: string, filterAccountId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/usage/audience_data/daily`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication apiKeyHeaderAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication apiKeyQueryParamAuth required
            await setApiKeyToObject(localVarQueryParameter, "api_key", configuration)

            if (filterDateFrom !== undefined) {
                localVarQueryParameter['filter[date][from]'] = (filterDateFrom as any instanceof Date) ?
                    (filterDateFrom as any).toISOString().substring(0,10) :
                    filterDateFrom;
            }

            if (filterDateTo !== undefined) {
                localVarQueryParameter['filter[date][to]'] = (filterDateTo as any instanceof Date) ?
                    (filterDateTo as any).toISOString().substring(0,10) :
                    filterDateTo;
            }

            if (filterAccountId !== undefined) {
                localVarQueryParameter['filter[account_id]'] = filterAccountId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Provides usage stats on a monthly basis.
         * @summary List monthly usage of Audience Data
         * @param {number} [filterYear] Year to filter by
         * @param {string} [filterAccountId] Optional parameter used to query usage of specific account IDs (only available to super admins). 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAudienceDataMonthlyUsage: async (filterYear?: number, filterAccountId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/usage/audience_data/monthly`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication apiKeyHeaderAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication apiKeyQueryParamAuth required
            await setApiKeyToObject(localVarQueryParameter, "api_key", configuration)

            if (filterYear !== undefined) {
                localVarQueryParameter['filter[year]'] = filterYear;
            }

            if (filterAccountId !== undefined) {
                localVarQueryParameter['filter[account_id]'] = filterAccountId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Provides usage stats on a near-realtime basis. Results available for the last 24 hours, provided with as short delay as possible.
         * @summary List realtime usage of Audience Data
         * @param {string} [filterAccountId] Optional parameter used to query usage of specific account IDs (only available to super admins). 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAudienceDataRealtimeUsage: async (filterAccountId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/usage/audience_data/realtime`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication apiKeyHeaderAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication apiKeyQueryParamAuth required
            await setApiKeyToObject(localVarQueryParameter, "api_key", configuration)

            if (filterAccountId !== undefined) {
                localVarQueryParameter['filter[account_id]'] = filterAccountId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsageApi - functional programming interface
 * @export
 */
export const UsageApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsageApiAxiosParamCreator(configuration)
    return {
        /**
         * Provides usage stats on a daily basis. Results available for the last 2 months.
         * @summary List daily usage of Audience Data
         * @param {string} [filterDateFrom] Date to query from
         * @param {string} [filterDateTo] Date to query to
         * @param {string} [filterAccountId] Optional parameter used to query usage of specific account IDs (only available to super admins). 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAudienceDataDailyUsage(filterDateFrom?: string, filterDateTo?: string, filterAccountId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListAudienceDataDailyUsage200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAudienceDataDailyUsage(filterDateFrom, filterDateTo, filterAccountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsageApi.listAudienceDataDailyUsage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Provides usage stats on a monthly basis.
         * @summary List monthly usage of Audience Data
         * @param {number} [filterYear] Year to filter by
         * @param {string} [filterAccountId] Optional parameter used to query usage of specific account IDs (only available to super admins). 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAudienceDataMonthlyUsage(filterYear?: number, filterAccountId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListAudienceDataMonthlyUsage200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAudienceDataMonthlyUsage(filterYear, filterAccountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsageApi.listAudienceDataMonthlyUsage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Provides usage stats on a near-realtime basis. Results available for the last 24 hours, provided with as short delay as possible.
         * @summary List realtime usage of Audience Data
         * @param {string} [filterAccountId] Optional parameter used to query usage of specific account IDs (only available to super admins). 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAudienceDataRealtimeUsage(filterAccountId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListAudienceDataRealtimeUsage200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAudienceDataRealtimeUsage(filterAccountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsageApi.listAudienceDataRealtimeUsage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsageApi - factory interface
 * @export
 */
export const UsageApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsageApiFp(configuration)
    return {
        /**
         * Provides usage stats on a daily basis. Results available for the last 2 months.
         * @summary List daily usage of Audience Data
         * @param {string} [filterDateFrom] Date to query from
         * @param {string} [filterDateTo] Date to query to
         * @param {string} [filterAccountId] Optional parameter used to query usage of specific account IDs (only available to super admins). 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAudienceDataDailyUsage(filterDateFrom?: string, filterDateTo?: string, filterAccountId?: string, options?: any): AxiosPromise<ListAudienceDataDailyUsage200Response> {
            return localVarFp.listAudienceDataDailyUsage(filterDateFrom, filterDateTo, filterAccountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Provides usage stats on a monthly basis.
         * @summary List monthly usage of Audience Data
         * @param {number} [filterYear] Year to filter by
         * @param {string} [filterAccountId] Optional parameter used to query usage of specific account IDs (only available to super admins). 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAudienceDataMonthlyUsage(filterYear?: number, filterAccountId?: string, options?: any): AxiosPromise<ListAudienceDataMonthlyUsage200Response> {
            return localVarFp.listAudienceDataMonthlyUsage(filterYear, filterAccountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Provides usage stats on a near-realtime basis. Results available for the last 24 hours, provided with as short delay as possible.
         * @summary List realtime usage of Audience Data
         * @param {string} [filterAccountId] Optional parameter used to query usage of specific account IDs (only available to super admins). 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAudienceDataRealtimeUsage(filterAccountId?: string, options?: any): AxiosPromise<ListAudienceDataRealtimeUsage200Response> {
            return localVarFp.listAudienceDataRealtimeUsage(filterAccountId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsageApi - object-oriented interface
 * @export
 * @class UsageApi
 * @extends {BaseAPI}
 */
export class UsageApi extends BaseAPI {
    /**
     * Provides usage stats on a daily basis. Results available for the last 2 months.
     * @summary List daily usage of Audience Data
     * @param {string} [filterDateFrom] Date to query from
     * @param {string} [filterDateTo] Date to query to
     * @param {string} [filterAccountId] Optional parameter used to query usage of specific account IDs (only available to super admins). 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsageApi
     */
    public listAudienceDataDailyUsage(filterDateFrom?: string, filterDateTo?: string, filterAccountId?: string, options?: RawAxiosRequestConfig) {
        return UsageApiFp(this.configuration).listAudienceDataDailyUsage(filterDateFrom, filterDateTo, filterAccountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Provides usage stats on a monthly basis.
     * @summary List monthly usage of Audience Data
     * @param {number} [filterYear] Year to filter by
     * @param {string} [filterAccountId] Optional parameter used to query usage of specific account IDs (only available to super admins). 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsageApi
     */
    public listAudienceDataMonthlyUsage(filterYear?: number, filterAccountId?: string, options?: RawAxiosRequestConfig) {
        return UsageApiFp(this.configuration).listAudienceDataMonthlyUsage(filterYear, filterAccountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Provides usage stats on a near-realtime basis. Results available for the last 24 hours, provided with as short delay as possible.
     * @summary List realtime usage of Audience Data
     * @param {string} [filterAccountId] Optional parameter used to query usage of specific account IDs (only available to super admins). 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsageApi
     */
    public listAudienceDataRealtimeUsage(filterAccountId?: string, options?: RawAxiosRequestConfig) {
        return UsageApiFp(this.configuration).listAudienceDataRealtimeUsage(filterAccountId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create API key for the given user. When an API key is created, the `token` value will be exposed in the response. This token can be passed as the `X-API-KEY` header value for future requests. It is not obtainable in other API requests (ie. the client must decide how to keep the API key token in e.g. a vault or similar). 
         * @summary Create API key
         * @param {string} userId 
         * @param {ApiKeyCreation} apiKeyCreation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApiKey: async (userId: string, apiKeyCreation: ApiKeyCreation, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('createApiKey', 'userId', userId)
            // verify required parameter 'apiKeyCreation' is not null or undefined
            assertParamExists('createApiKey', 'apiKeyCreation', apiKeyCreation)
            const localVarPath = `/users/{user_id}/apikeys`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication apiKeyHeaderAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication apiKeyQueryParamAuth required
            await setApiKeyToObject(localVarQueryParameter, "api_key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiKeyCreation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a user within the referenced account. 
         * @summary Create user
         * @param {string} accountId 
         * @param {UserCreation} userCreation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserInAccount: async (accountId: string, userCreation: UserCreation, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('createUserInAccount', 'accountId', accountId)
            // verify required parameter 'userCreation' is not null or undefined
            assertParamExists('createUserInAccount', 'userCreation', userCreation)
            const localVarPath = `/accounts/{account_id}/users`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication apiKeyHeaderAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication apiKeyQueryParamAuth required
            await setApiKeyToObject(localVarQueryParameter, "api_key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userCreation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete API key
         * @param {string} userId 
         * @param {string} keyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApiKeyById: async (userId: string, keyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteApiKeyById', 'userId', userId)
            // verify required parameter 'keyId' is not null or undefined
            assertParamExists('deleteApiKeyById', 'keyId', keyId)
            const localVarPath = `/users/{user_id}/apikeys/{key_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"key_id"}}`, encodeURIComponent(String(keyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication apiKeyHeaderAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication apiKeyQueryParamAuth required
            await setApiKeyToObject(localVarQueryParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the avatar for a user 
         * @summary Delete user avatar
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserAvatar: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteUserAvatar', 'userId', userId)
            const localVarPath = `/users/{user_id}/assets/avatar`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication apiKeyHeaderAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication apiKeyQueryParamAuth required
            await setApiKeyToObject(localVarQueryParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete user
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserById: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteUserById', 'userId', userId)
            const localVarPath = `/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication apiKeyHeaderAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication apiKeyQueryParamAuth required
            await setApiKeyToObject(localVarQueryParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get API key
         * @param {string} userId 
         * @param {string} keyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiKeyById: async (userId: string, keyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getApiKeyById', 'userId', userId)
            // verify required parameter 'keyId' is not null or undefined
            assertParamExists('getApiKeyById', 'keyId', keyId)
            const localVarPath = `/users/{user_id}/apikeys/{key_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"key_id"}}`, encodeURIComponent(String(keyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication apiKeyHeaderAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication apiKeyQueryParamAuth required
            await setApiKeyToObject(localVarQueryParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information about the currently authenticated user
         * @summary Get current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication apiKeyHeaderAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication apiKeyQueryParamAuth required
            await setApiKeyToObject(localVarQueryParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the user avatar, if the image is hosted on the Digiseg platform. Refer to the user\'s `avatar_url` to get a non-authenticated and shareable URL for the avatar. 
         * @summary Get user avatar
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAvatar: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserAvatar', 'userId', userId)
            const localVarPath = `/users/{user_id}/assets/avatar`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication apiKeyHeaderAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication apiKeyQueryParamAuth required
            await setApiKeyToObject(localVarQueryParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get user
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserById: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserById', 'userId', userId)
            const localVarPath = `/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication apiKeyHeaderAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication apiKeyQueryParamAuth required
            await setApiKeyToObject(localVarQueryParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List API keys for user
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApiKeysByUserId: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('listApiKeysByUserId', 'userId', userId)
            const localVarPath = `/users/{user_id}/apikeys`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication apiKeyHeaderAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication apiKeyQueryParamAuth required
            await setApiKeyToObject(localVarQueryParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List users for account
         * @param {string} accountId 
         * @param {UserPlatformRole} [filterPlatformRoles] Filter based on platform roles, e.g. super_admin
         * @param {string} [filterNameContains] Optional parameter used to search for users where the name contains a substring (case insensitive)
         * @param {UserSortOption} [sort] Defines the field to sort the result items by. Ascending order is applied by default, but the minus character can be used to indicate descending order instead. 
         * @param {number} [pageSize] The desired page size
         * @param {string} [pageAfter] Optional pagination parameter, indicating the previous cursor value to paginate beyond. The value to provide here is opaque, but can be found in previous requests in the &#x60;meta.page.last_cursor&#x60; field. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsersByAccountId: async (accountId: string, filterPlatformRoles?: UserPlatformRole, filterNameContains?: string, sort?: UserSortOption, pageSize?: number, pageAfter?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('listUsersByAccountId', 'accountId', accountId)
            const localVarPath = `/accounts/{account_id}/users`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication apiKeyHeaderAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication apiKeyQueryParamAuth required
            await setApiKeyToObject(localVarQueryParameter, "api_key", configuration)

            if (filterPlatformRoles !== undefined) {
                localVarQueryParameter['filter[platform_roles]'] = filterPlatformRoles;
            }

            if (filterNameContains !== undefined) {
                localVarQueryParameter['filter[name][contains]'] = filterNameContains;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page[size]'] = pageSize;
            }

            if (pageAfter !== undefined) {
                localVarQueryParameter['page[after]'] = pageAfter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update API key
         * @param {string} userId 
         * @param {string} keyId 
         * @param {ApiKeyMutation} apiKeyMutation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApiKeyById: async (userId: string, keyId: string, apiKeyMutation: ApiKeyMutation, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateApiKeyById', 'userId', userId)
            // verify required parameter 'keyId' is not null or undefined
            assertParamExists('updateApiKeyById', 'keyId', keyId)
            // verify required parameter 'apiKeyMutation' is not null or undefined
            assertParamExists('updateApiKeyById', 'apiKeyMutation', apiKeyMutation)
            const localVarPath = `/users/{user_id}/apikeys/{key_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"key_id"}}`, encodeURIComponent(String(keyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication apiKeyHeaderAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication apiKeyQueryParamAuth required
            await setApiKeyToObject(localVarQueryParameter, "api_key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiKeyMutation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update user
         * @param {string} userId 
         * @param {UserMutation} userMutation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserById: async (userId: string, userMutation: UserMutation, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateUserById', 'userId', userId)
            // verify required parameter 'userMutation' is not null or undefined
            assertParamExists('updateUserById', 'userMutation', userMutation)
            const localVarPath = `/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication apiKeyHeaderAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication apiKeyQueryParamAuth required
            await setApiKeyToObject(localVarQueryParameter, "api_key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userMutation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload a avatar for a user 
         * @summary Upload user avatar
         * @param {string} userId 
         * @param {File} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadUserAvatar: async (userId: string, body: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('uploadUserAvatar', 'userId', userId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('uploadUserAvatar', 'body', body)
            const localVarPath = `/users/{user_id}/assets/avatar`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth", [], configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication apiKeyHeaderAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication apiKeyQueryParamAuth required
            await setApiKeyToObject(localVarQueryParameter, "api_key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'image/gif';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * Create API key for the given user. When an API key is created, the `token` value will be exposed in the response. This token can be passed as the `X-API-KEY` header value for future requests. It is not obtainable in other API requests (ie. the client must decide how to keep the API key token in e.g. a vault or similar). 
         * @summary Create API key
         * @param {string} userId 
         * @param {ApiKeyCreation} apiKeyCreation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createApiKey(userId: string, apiKeyCreation: ApiKeyCreation, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateApiKey201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createApiKey(userId, apiKeyCreation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.createApiKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a user within the referenced account. 
         * @summary Create user
         * @param {string} accountId 
         * @param {UserCreation} userCreation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserInAccount(accountId: string, userCreation: UserCreation, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateUserInAccount201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUserInAccount(accountId, userCreation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.createUserInAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete API key
         * @param {string} userId 
         * @param {string} keyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteApiKeyById(userId: string, keyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteApiKeyById(userId, keyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.deleteApiKeyById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes the avatar for a user 
         * @summary Delete user avatar
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserAvatar(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserAvatar(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.deleteUserAvatar']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete user
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserById(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserById(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.deleteUserById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get API key
         * @param {string} userId 
         * @param {string} keyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApiKeyById(userId: string, keyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetApiKeyById200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApiKeyById(userId, keyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getApiKeyById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get information about the currently authenticated user
         * @summary Get current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCurrentUser(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateUserInAccount201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrentUser(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getCurrentUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Gets the user avatar, if the image is hosted on the Digiseg platform. Refer to the user\'s `avatar_url` to get a non-authenticated and shareable URL for the avatar. 
         * @summary Get user avatar
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserAvatar(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserAvatar(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getUserAvatar']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get user
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserById(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateUserInAccount201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserById(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getUserById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List API keys for user
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listApiKeysByUserId(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListApiKeysByAccountId200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listApiKeysByUserId(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.listApiKeysByUserId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List users for account
         * @param {string} accountId 
         * @param {UserPlatformRole} [filterPlatformRoles] Filter based on platform roles, e.g. super_admin
         * @param {string} [filterNameContains] Optional parameter used to search for users where the name contains a substring (case insensitive)
         * @param {UserSortOption} [sort] Defines the field to sort the result items by. Ascending order is applied by default, but the minus character can be used to indicate descending order instead. 
         * @param {number} [pageSize] The desired page size
         * @param {string} [pageAfter] Optional pagination parameter, indicating the previous cursor value to paginate beyond. The value to provide here is opaque, but can be found in previous requests in the &#x60;meta.page.last_cursor&#x60; field. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUsersByAccountId(accountId: string, filterPlatformRoles?: UserPlatformRole, filterNameContains?: string, sort?: UserSortOption, pageSize?: number, pageAfter?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListUsersByAccountId200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUsersByAccountId(accountId, filterPlatformRoles, filterNameContains, sort, pageSize, pageAfter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.listUsersByAccountId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update API key
         * @param {string} userId 
         * @param {string} keyId 
         * @param {ApiKeyMutation} apiKeyMutation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateApiKeyById(userId: string, keyId: string, apiKeyMutation: ApiKeyMutation, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetApiKeyById200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateApiKeyById(userId, keyId, apiKeyMutation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.updateApiKeyById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update user
         * @param {string} userId 
         * @param {UserMutation} userMutation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserById(userId: string, userMutation: UserMutation, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateUserInAccount201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserById(userId, userMutation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.updateUserById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Upload a avatar for a user 
         * @summary Upload user avatar
         * @param {string} userId 
         * @param {File} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadUserAvatar(userId: string, body: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadUserAvatar(userId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.uploadUserAvatar']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * Create API key for the given user. When an API key is created, the `token` value will be exposed in the response. This token can be passed as the `X-API-KEY` header value for future requests. It is not obtainable in other API requests (ie. the client must decide how to keep the API key token in e.g. a vault or similar). 
         * @summary Create API key
         * @param {string} userId 
         * @param {ApiKeyCreation} apiKeyCreation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApiKey(userId: string, apiKeyCreation: ApiKeyCreation, options?: any): AxiosPromise<CreateApiKey201Response> {
            return localVarFp.createApiKey(userId, apiKeyCreation, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a user within the referenced account. 
         * @summary Create user
         * @param {string} accountId 
         * @param {UserCreation} userCreation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserInAccount(accountId: string, userCreation: UserCreation, options?: any): AxiosPromise<CreateUserInAccount201Response> {
            return localVarFp.createUserInAccount(accountId, userCreation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete API key
         * @param {string} userId 
         * @param {string} keyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApiKeyById(userId: string, keyId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteApiKeyById(userId, keyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the avatar for a user 
         * @summary Delete user avatar
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserAvatar(userId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteUserAvatar(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete user
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserById(userId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteUserById(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get API key
         * @param {string} userId 
         * @param {string} keyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiKeyById(userId: string, keyId: string, options?: any): AxiosPromise<GetApiKeyById200Response> {
            return localVarFp.getApiKeyById(userId, keyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get information about the currently authenticated user
         * @summary Get current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser(options?: any): AxiosPromise<CreateUserInAccount201Response> {
            return localVarFp.getCurrentUser(options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the user avatar, if the image is hosted on the Digiseg platform. Refer to the user\'s `avatar_url` to get a non-authenticated and shareable URL for the avatar. 
         * @summary Get user avatar
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAvatar(userId: string, options?: any): AxiosPromise<void> {
            return localVarFp.getUserAvatar(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get user
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserById(userId: string, options?: any): AxiosPromise<CreateUserInAccount201Response> {
            return localVarFp.getUserById(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List API keys for user
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApiKeysByUserId(userId: string, options?: any): AxiosPromise<ListApiKeysByAccountId200Response> {
            return localVarFp.listApiKeysByUserId(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List users for account
         * @param {string} accountId 
         * @param {UserPlatformRole} [filterPlatformRoles] Filter based on platform roles, e.g. super_admin
         * @param {string} [filterNameContains] Optional parameter used to search for users where the name contains a substring (case insensitive)
         * @param {UserSortOption} [sort] Defines the field to sort the result items by. Ascending order is applied by default, but the minus character can be used to indicate descending order instead. 
         * @param {number} [pageSize] The desired page size
         * @param {string} [pageAfter] Optional pagination parameter, indicating the previous cursor value to paginate beyond. The value to provide here is opaque, but can be found in previous requests in the &#x60;meta.page.last_cursor&#x60; field. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsersByAccountId(accountId: string, filterPlatformRoles?: UserPlatformRole, filterNameContains?: string, sort?: UserSortOption, pageSize?: number, pageAfter?: string, options?: any): AxiosPromise<ListUsersByAccountId200Response> {
            return localVarFp.listUsersByAccountId(accountId, filterPlatformRoles, filterNameContains, sort, pageSize, pageAfter, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update API key
         * @param {string} userId 
         * @param {string} keyId 
         * @param {ApiKeyMutation} apiKeyMutation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApiKeyById(userId: string, keyId: string, apiKeyMutation: ApiKeyMutation, options?: any): AxiosPromise<GetApiKeyById200Response> {
            return localVarFp.updateApiKeyById(userId, keyId, apiKeyMutation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update user
         * @param {string} userId 
         * @param {UserMutation} userMutation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserById(userId: string, userMutation: UserMutation, options?: any): AxiosPromise<CreateUserInAccount201Response> {
            return localVarFp.updateUserById(userId, userMutation, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload a avatar for a user 
         * @summary Upload user avatar
         * @param {string} userId 
         * @param {File} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadUserAvatar(userId: string, body: File, options?: any): AxiosPromise<void> {
            return localVarFp.uploadUserAvatar(userId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * Create API key for the given user. When an API key is created, the `token` value will be exposed in the response. This token can be passed as the `X-API-KEY` header value for future requests. It is not obtainable in other API requests (ie. the client must decide how to keep the API key token in e.g. a vault or similar). 
     * @summary Create API key
     * @param {string} userId 
     * @param {ApiKeyCreation} apiKeyCreation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public createApiKey(userId: string, apiKeyCreation: ApiKeyCreation, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).createApiKey(userId, apiKeyCreation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a user within the referenced account. 
     * @summary Create user
     * @param {string} accountId 
     * @param {UserCreation} userCreation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public createUserInAccount(accountId: string, userCreation: UserCreation, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).createUserInAccount(accountId, userCreation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete API key
     * @param {string} userId 
     * @param {string} keyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deleteApiKeyById(userId: string, keyId: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).deleteApiKeyById(userId, keyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the avatar for a user 
     * @summary Delete user avatar
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deleteUserAvatar(userId: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).deleteUserAvatar(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete user
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deleteUserById(userId: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).deleteUserById(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get API key
     * @param {string} userId 
     * @param {string} keyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getApiKeyById(userId: string, keyId: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getApiKeyById(userId, keyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get information about the currently authenticated user
     * @summary Get current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getCurrentUser(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getCurrentUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets the user avatar, if the image is hosted on the Digiseg platform. Refer to the user\'s `avatar_url` to get a non-authenticated and shareable URL for the avatar. 
     * @summary Get user avatar
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUserAvatar(userId: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUserAvatar(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get user
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUserById(userId: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUserById(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List API keys for user
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public listApiKeysByUserId(userId: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).listApiKeysByUserId(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List users for account
     * @param {string} accountId 
     * @param {UserPlatformRole} [filterPlatformRoles] Filter based on platform roles, e.g. super_admin
     * @param {string} [filterNameContains] Optional parameter used to search for users where the name contains a substring (case insensitive)
     * @param {UserSortOption} [sort] Defines the field to sort the result items by. Ascending order is applied by default, but the minus character can be used to indicate descending order instead. 
     * @param {number} [pageSize] The desired page size
     * @param {string} [pageAfter] Optional pagination parameter, indicating the previous cursor value to paginate beyond. The value to provide here is opaque, but can be found in previous requests in the &#x60;meta.page.last_cursor&#x60; field. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public listUsersByAccountId(accountId: string, filterPlatformRoles?: UserPlatformRole, filterNameContains?: string, sort?: UserSortOption, pageSize?: number, pageAfter?: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).listUsersByAccountId(accountId, filterPlatformRoles, filterNameContains, sort, pageSize, pageAfter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update API key
     * @param {string} userId 
     * @param {string} keyId 
     * @param {ApiKeyMutation} apiKeyMutation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateApiKeyById(userId: string, keyId: string, apiKeyMutation: ApiKeyMutation, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateApiKeyById(userId, keyId, apiKeyMutation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update user
     * @param {string} userId 
     * @param {UserMutation} userMutation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUserById(userId: string, userMutation: UserMutation, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateUserById(userId, userMutation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload a avatar for a user 
     * @summary Upload user avatar
     * @param {string} userId 
     * @param {File} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public uploadUserAvatar(userId: string, body: File, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).uploadUserAvatar(userId, body, options).then((request) => request(this.axios, this.basePath));
    }
}



